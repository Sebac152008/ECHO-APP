// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Importa la vista principal u otras vistas personalizadas desde el proyecto ECHO
using ECHO.View;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Proporciona clases y estructuras base del sistema como DateTime, String, Int32, etc.
using System;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Permite trabajar con colecciones genéricas como List<T>, Dictionary<TKey, TValue>, etc.
using System.Collections.Generic;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Contiene métodos útiles para consultas y manipulación de colecciones con LINQ (ej: Where, Select, FirstOrDefault)
using System.Linq;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Proporciona herramientas para codificación y manipulación de cadenas como StringBuilder, Encoding, etc.
using System.Text;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Contiene clases para trabajar con tareas asincrónicas (como Task, async/await)
using System.Threading.Tasks;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Proporciona acceso a funcionalidades de la aplicación WPF como ventanas, mensajes, etc.
using System.Windows;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Contiene controles visuales de WPF como Button, TextBox, StackPanel, etc.
using System.Windows.Controls;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Proporciona soporte para el enlace de datos (data binding) en WPF
using System.Windows.Data;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Permite manipular contenido de tipo documento como FlowDocuments, Paragraph, Run, etc.
using System.Windows.Documents;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Permite manejar la entrada del usuario como eventos de teclado y mouse
using System.Windows.Input;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Importa las clases necesarias para trabajar con bases de datos SQLite
using System.Data.SQLite;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Proporciona clases para manejar colores, pinceles, degradados y dibujo en general
using System.Windows.Media;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Permite trabajar con imágenes en WPF, como BitmapImage o ImageSource
using System.Windows.Media.Imaging;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Permite navegar entre páginas o vistas en aplicaciones WPF que utilizan navegación (NavigationWindow, Page)
using System.Windows.Navigation;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Permite manipular formas básicas como rectángulos, líneas, polígonos, etc.
using System.Windows.Shapes;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Importa los estilos, controles y utilidades del paquete Material Design in XAML Toolkit
using MaterialDesignThemes.Wpf;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Proporciona clases para crear animaciones como DoubleAnimation, Storyboard, etc.
using System.Windows.Media.Animation;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Importa clases o recursos personalizados definidos en la carpeta "Recursos" del proyecto ECHO
using ECHO.Recursos;


// La palabra clave "namespace" se utiliza para organizar y agrupar clases relacionadas bajo un mismo nombre lógico.
// Esto ayuda a evitar conflictos de nombres y mejora la organización del código.
// En este caso, el espacio de nombres se llama WPF_ECHO.View y contiene las vistas de la aplicación.
// Aparte el namespace puede ser llamado como el nombre del programa.
namespace WPF_ECHO.View
{
    /// <summary>
    /// Lógica de interacción para BuscarView.xaml
    /// </summary>

    // Declaración parcial de la clase 'BuscarView'
    // 'public' indica que esta clase puede ser accedida desde cualquier otro archivo o clase
    // 'partial' significa que esta clase está dividida en más de un archivo (por ejemplo: BuscarView.xaml.cs y BuscarView.xaml)
    // 'class' define una clase en C#
    // 'BuscarView' es el nombre de esta clase, que representa una vista o pantalla de búsqueda en tu aplicación
    // ': UserControl' indica que esta clase hereda de 'UserControl', una clase de WPF que permite crear controles personalizados con interfaz de usuario
    public partial class BuscarView : UserControl
    {
        // Constructor de la clase BuscarView. Se ejecuta automáticamente cuando se crea una instancia de esta vista.
        public BuscarView()
        {
            InitializeComponent(); // Inicializa todos los componentes definidos en el archivo XAML asociado a esta vista.

            // Obtiene una animación llamada "VentanaAbrirAnimacion" definida en los recursos XAML y la asigna a la variable 'abrirAnim'
            Storyboard abrirAnim = (Storyboard)this.Resources["VentanaAbrirAnimacion"];

            // Inicia la animación de apertura para la vista actual
            abrirAnim.Begin(this);

            // Suscribe el evento 'Loaded' (cuando la vista termina de cargarse) al método 'BuscarView_Loaded'
            this.Loaded += BuscarView_Loaded;
        }

        // Método que se ejecuta cuando la vista ha terminado de cargarse completamente en la ventana
        private void BuscarView_Loaded(object sender, RoutedEventArgs e)
        {
            // Vuelve a ejecutar la animación de apertura al completarse la carga de la vista
            Storyboard abrirAnim = (Storyboard)this.Resources["VentanaAbrirAnimacion"];
            abrirAnim.Begin(this);
        }

        // Cadena de conexión estática y de solo lectura para conectarse a la base de datos SQLite.
        // Se obtiene desde una instancia global de 'AppContexto', que centraliza la configuración de la app.
        private static readonly string connectionString = AppContexto.Instancia.ConexionBD;


        private void txtBuscarRecordatorio_TextChanged(object sender, TextChangedEventArgs e)
        {
            // Obtiene el texto ingresado en el campo de búsqueda, elimina espacios en blanco al inicio y final,
            // convierte el texto a minúsculas para hacer la búsqueda insensible a mayúsculas/minúsculas,
            // y además elimina los acentos para hacer la búsqueda más flexible.
            string filtro = QuitarAcentos(txtBuscarRecordatorio.Text.Trim().ToLower());

            // Limpia el contenedor visual donde se muestran los resultados para que no se acumulen resultados antiguos
            StackResultados.Children.Clear();

            // Si el filtro está vacío (es decir, el usuario no escribió nada), se detiene la ejecución del método,
            // evitando hacer una consulta innecesaria o mostrar resultados sin sentido.
            if (string.IsNullOrEmpty(filtro))
                return;


            try
            {
                // Crear una conexión a la base de datos SQLite usando la cadena de conexión almacenada
                using (var connection = new SQLiteConnection(connectionString))
                {
                    // Abrir la conexión para poder ejecutar comandos
                    connection.Open();

                    // Definir la consulta SQL para seleccionar todos los recordatorios donde el texto en 'Nota'
                    // contenga el filtro (buscado en minúsculas)
                    string query = "SELECT * FROM Recordatorios WHERE LOWER(Nota) LIKE @filtro";

                    // Crear un comando SQLite con la consulta y la conexión abierta
                    using (var command = new SQLiteCommand(query, connection))
                    {
                        // Añadir el parámetro '@filtro' a la consulta, usando el texto filtrado entre comodines '%'
                        command.Parameters.AddWithValue("@filtro", $"%{filtro}%");

                        // Ejecutar el comando y obtener un lector para recorrer los resultados devueltos
                        using (var reader = command.ExecuteReader())
                        {
                            // Leer fila por fila mientras haya datos disponibles
                            while (reader.Read())
                            {
                                // Crear una nueva instancia del control RecordatorioItem para mostrar el recordatorio
                                var item = new RecordatorioItem
                                {
                                    // Asignar la propiedad ID con el valor entero del campo 'ID_Recordatorios' del resultado
                                    ID_Recordatorios = Convert.ToInt32(reader["ID_Recordatorios"]),

                                    // Asignar la propiedad Descripcion con el texto del campo 'Nota'
                                    Descripcion = reader["Nota"].ToString(),

                                    // Asignar la propiedad Fecha con el texto del campo 'Fecha'
                                    Fecha = reader["Fecha"].ToString(),

                                    // Asignar la propiedad Hora con el texto del campo 'Hora'
                                    Hora = reader["Hora"].ToString()
                                };

                                // Comprobar si el recordatorio está marcado como destacado (1 = destacado)
                                bool esDestacado = Convert.ToInt32(reader["Destacado"]) == 1;

                                // Actualizar visualmente el estado destacado del item según lo obtenido de la BD
                                item.SetEstaDestacadoDesdeBD(esDestacado);

                                // Buscar dentro del control item un TextBlock llamado "TxtNota" para aplicar resaltado visual
                                var textBlock = item.FindName("TxtNota") as TextBlock;

                                // Si se encontró el TextBlock, aplicar resaltado a las coincidencias del texto
                                if (textBlock != null)
                                {
                                    AplicarResaltadoEnTextBlock(textBlock, item.Descripcion, filtro);
                                }

                                // Suscribirse al evento que se dispara cuando se solicita eliminar este recordatorio
                                item.EliminarRecordatorio += async (s, ev) =>
                                {
                                    // Mostrar diálogo para confirmar si el usuario quiere eliminar el recordatorio
                                    var resultado = await MostrarDialogoEliminacion();

                                    // Si el usuario confirmó la eliminación
                                    if (resultado)
                                    {
                                        // Eliminar el recordatorio de la base de datos usando su ID
                                        EliminarRecordatorioDeBD(item.ID_Recordatorios);

                                        // Remover el control visual del contenedor de resultados en la interfaz
                                        StackResultados.Children.Remove(item);

                                        // Mostrar un mensaje de confirmación de eliminación con un icono
                                        MostrarMensaje("Recordatorio eliminado", "eliminar.png");
                                    }
                                };


                                // Suscribirse al evento que se dispara al hacer clic en el botón de editar del recordatorio
                                item.EditarClicked += async (s, args) =>
                                {
                                    // Llamar de forma asíncrona al método que abre el diálogo para editar el recordatorio actual
                                    await EditarRecordatorio(item);
                                };

                                // Suscribirse al evento que se dispara al cambiar el estado de "destacado" (estrella) del recordatorio
                                item.DestacadoCambiado += (s, isDestacado) =>
                                {
                                    try
                                    {
                                        // Abrir conexión a la base de datos para actualizar el estado destacado
                                        using (var conn = new SQLiteConnection(connectionString))
                                        {
                                            conn.Open();

                                            // Crear el comando SQL para actualizar el campo Destacado en la tabla Recordatorios
                                            // Se guarda 1 si el recordatorio está destacado, 0 si no
                                            var cmd = new SQLiteCommand(
                                                "UPDATE Recordatorios SET Destacado = @dest WHERE ID_Recordatorios = @id",
                                                conn);

                                            // Parámetro @dest recibe 1 o 0 según el valor booleano isDestacado
                                            cmd.Parameters.AddWithValue("@dest", isDestacado ? 1 : 0);

                                            // Parámetro @id para identificar qué recordatorio actualizar
                                            cmd.Parameters.AddWithValue("@id", item.ID_Recordatorios);

                                            // Ejecutar la actualización en la base de datos
                                            cmd.ExecuteNonQuery();
                                        }

                                        // Actualizar visualmente el control para reflejar el nuevo estado destacado
                                        item.SetEstaDestacadoDesdeBD(isDestacado);

                                        // Mostrar un mensaje tipo "toast" con texto e icono según se destacó o se desmarcó
                                        MostrarMensaje(
                                            isDestacado ? "Recordatorio destacado" : "Recordatorio desmarcado",
                                            isDestacado ? "EstrellaRellenada.png" : "EstrellaVaciaAmarilla.png"
                                        );

                                        // Refrescar la vista que muestra los recordatorios destacados para actualizar la lista visible
                                        DestacadoView.InstanciaActual?.RecargarRecordatorios();

                                        // Opcionalmente, refrescar la búsqueda actual para ocultar el recordatorio si se desmarcó
                                        txtBuscarRecordatorio_TextChanged(null, null);
                                    }
                                    catch (Exception ex)
                                    {
                                        // Mostrar mensaje de error si ocurre alguna excepción al cambiar el estado destacado
                                        MessageBox.Show("Error al cambiar destacado: " + ex.Message);
                                    }
                                };

                                // Finalmente, añadir el control item creado al contenedor visual donde se muestran los resultados
                                StackResultados.Children.Add(item);

                            }
                        }
                    }
                }
            }
            // Captura cualquier excepción que ocurra durante la ejecución del bloque try anterior
            catch (Exception ex)
            {
                // Muestra un mensaje emergente con la descripción del error ocurrido al realizar la búsqueda
                MessageBox.Show($"Error al buscar: {ex.Message}");
            }

        }


        // Método encargado de aplicar un resaltado visual en un TextBlock para marcar la parte del texto que coincide con el filtro de búsqueda.
        // Recibe el TextBlock donde se mostrará el texto, el texto original completo y el filtro (texto buscado) que se desea resaltar.
        private void AplicarResaltadoEnTextBlock(TextBlock textBlock, string textoOriginal, string filtro)
        {
            // Limpiamos completamente el contenido del TextBlock para preparar la inserción del texto formateado.
            // Se elimina cualquier texto e inlines (partes con estilos) previamente agregados.
            textBlock.Text = string.Empty;
            textBlock.Inlines.Clear();

            // Para hacer una búsqueda insensible a mayúsculas, minúsculas y acentos:
            // Convertimos el texto original a minúsculas y quitamos los acentos para normalizarlo.
            string textoSinAcentos = QuitarAcentos(textoOriginal.ToLower());

            // Buscamos la posición donde aparece el filtro dentro del texto normalizado.
            // Si no se encuentra, el índice será -1.
            int index = textoSinAcentos.IndexOf(filtro);

            // Si el filtro fue encontrado dentro del texto (index >= 0), se procede a dividir el texto en tres partes:
            // antes de la coincidencia, la coincidencia en sí, y lo que queda después.
            if (index >= 0)
            {
                // Extraemos el texto antes de la coincidencia para mostrarlo sin resaltar.
                string antes = textoOriginal.Substring(0, index);

                // Extraemos el texto que coincide exactamente con el filtro para resaltarlo.
                // Importante: se usa el texto original para respetar mayúsculas y acentos.
                string match = textoOriginal.Substring(index, filtro.Length);

                // Extraemos el texto que viene después de la coincidencia, también sin resaltar.
                string despues = textoOriginal.Substring(index + filtro.Length);

                // Añadimos al TextBlock la parte antes de la coincidencia, con un color gris tenue para no destacar.
                textBlock.Inlines.Add(new Run(antes)
                {
                    Foreground = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#7F8C8D")) // Gris
                });

                // Añadimos la parte que coincide con el filtro en negrita y color oscuro para destacarla visualmente.
                textBlock.Inlines.Add(new Run(match)
                {
                    FontWeight = FontWeights.Bold, // Negrita para mayor énfasis
                    Foreground = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#2C3E50")) // Azul oscuro
                });

                // Añadimos la parte después de la coincidencia, con el mismo color gris tenue que la primera parte.
                textBlock.Inlines.Add(new Run(despues)
                {
                    Foreground = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#7F8C8D")) // Gris
                });
            }
            else
            {
                // Si no hay coincidencias, simplemente mostramos el texto completo en color gris tenue,
                // sin ninguna parte resaltada porque no hay filtro que marcar.
                textBlock.Inlines.Add(new Run(textoOriginal)
                {
                    Foreground = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#7F8C8D")) // Gris
                });
            }
        }



        // Método que elimina los acentos (diacríticos) de una cadena de texto.
        // Esto es útil para hacer comparaciones o búsquedas insensibles a acentos.
        private string QuitarAcentos(string texto)
        {
            // Normaliza el texto a la forma D (decomposición), donde los caracteres con acentos
            // se descomponen en el carácter base + uno o más caracteres diacríticos separados.
            var normalizado = texto.Normalize(NormalizationForm.FormD);

            // StringBuilder para construir el texto final sin acentos.
            var sb = new StringBuilder();

            // Recorremos cada carácter del texto normalizado.
            foreach (var c in normalizado)
            {
                // Obtenemos la categoría Unicode del carácter actual.
                var unicodeCategory = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);

                // Los caracteres de categoría NonSpacingMark son marcas de acento o diacríticos que no ocupan espacio.
                // Se omiten para eliminar los acentos.
                if (unicodeCategory != System.Globalization.UnicodeCategory.NonSpacingMark)
                {
                    // Solo se agregan los caracteres que NO son marcas de acento, es decir, caracteres base.
                    sb.Append(c);
                }
            }

            // Finalmente, se normaliza la cadena resultante a la forma C (composición),
            // que junta caracteres base con sus diacríticos en una única representación estándar,
            // pero como ya eliminamos los diacríticos, queda sin acentos.
            return sb.ToString().Normalize(NormalizationForm.FormC);
        }


        // Evento que se dispara cuando el control Image ha terminado de cargarse y renderizarse en la interfaz.
        // Este método se encarga de cargar y mostrar una imagen de fondo desde los recursos globales de la aplicación.
        private void Image_Loaded(object sender, RoutedEventArgs e)
        {
            // Se verifica si en los recursos de la aplicación existe un objeto con la clave "ImagenFondo".
            // Esto asegura que la imagen de fondo esté disponible antes de intentar asignarla.
            if (Application.Current.Resources.Contains("ImagenFondo"))
            {
                // Obtiene la imagen almacenada en recursos, la convierte a BitmapImage y la asigna
                // como fuente (Source) del control FondoImagen, para que se muestre en la interfaz.
                FondoImagen.Source = (BitmapImage)Application.Current.Resources["ImagenFondo"];

                // Cambia la propiedad Visibility del control FondoImagen a Visible,
                // garantizando que la imagen se muestre al usuario.
                FondoImagen.Visibility = Visibility.Visible;
            }
            // En caso de que no exista el recurso "ImagenFondo",
            // no se realiza ninguna acción y el control FondoImagen permanece oculto o sin imagen asignada.
        }


        // Método asíncrono para editar un recordatorio existente.
        // Abre un diálogo para que el usuario modifique los datos, y si confirma,
        // actualiza el registro en la base de datos SQLite y refresca la vista.
        private async Task EditarRecordatorio(RecordatorioItem recordatorio)
        {
            // Crear una instancia del control de diálogo personalizado para editar recordatorios.
            var editarControl = new EditarRecordatorioDialog();

            // Inicializar los campos del diálogo con los datos actuales del recordatorio:
            // - El texto de la nota.
            editarControl.txtNotaEditar.Text = recordatorio.Descripcion;
            // - La fecha, convirtiendo la cadena almacenada a DateTime.
            editarControl.fechaEditar.SelectedDate = DateTime.Parse(recordatorio.Fecha);
            // - La hora, convirtiendo la cadena de hora a TimeSpan y sumándola a la fecha de hoy
            //   para asignarla al control que espera un DateTime o nullable DateTime.
            editarControl.horaEditar.SelectedTime = DateTime.Today + TimeSpan.Parse(recordatorio.Hora);

            // Mostrar el diálogo modal utilizando MaterialDesignThemes,
            // la llamada es asíncrona y se espera el resultado que indica si el usuario confirmó la edición.
            var resultado = await MaterialDesignThemes.Wpf.DialogHost.Show(editarControl, "MainDialogHost");

            // Comprobar si el usuario pulsó el botón de aceptar ("true" como string).
            if (resultado is "true")
            {
                // Capturar los nuevos valores ingresados en el diálogo:
                string nuevaNota = editarControl.txtNotaEditar.Text;
                DateTime? nuevaFecha = editarControl.fechaEditar.SelectedDate;
                TimeSpan? nuevaHora = editarControl.horaEditar.SelectedTime?.TimeOfDay;

                // Validar que los campos no estén vacíos o nulos antes de proceder con la actualización.
                if (!string.IsNullOrWhiteSpace(nuevaNota) && nuevaFecha != null && nuevaHora != null)
                {
                    try
                    {
                        // Abrir una conexión a la base de datos SQLite usando la cadena connectionString.
                        using (var conn = new SQLiteConnection(connectionString))
                        {
                            conn.Open();

                            // Crear el comando SQL para actualizar el recordatorio con los nuevos datos.
                            var cmd = new SQLiteCommand(
                                "UPDATE Recordatorios SET Nota=@nota, Fecha=@fecha, Hora=@hora WHERE ID_Recordatorios=@id",
                                conn);

                            // Asociar los parámetros con los valores nuevos para prevenir inyección SQL.
                            cmd.Parameters.AddWithValue("@nota", nuevaNota);
                            // La fecha se convierte a formato ISO (yyyy-MM-dd) para evitar problemas de formato.
                            cmd.Parameters.AddWithValue("@fecha", nuevaFecha.Value.ToString("yyyy-MM-dd"));
                            // La hora se formatea en hh:mm para guardar solo la parte de hora y minutos.
                            cmd.Parameters.AddWithValue("@hora", nuevaHora.Value.ToString(@"hh\:mm"));
                            cmd.Parameters.AddWithValue("@id", recordatorio.ID_Recordatorios);

                            // Ejecutar la consulta UPDATE, modificando el registro en la tabla Recordatorios.
                            cmd.ExecuteNonQuery();
                        }

                        // Mostrar una notificación visual (toast o mensaje) para informar que la edición fue exitosa.
                        MostrarMensaje("Recordatorio editado", "comprobado.png");

                        // Forzar una actualización de la búsqueda para reflejar el cambio en la interfaz.
                        txtBuscarRecordatorio_TextChanged(null, null);
                    }
                    catch (Exception ex)
                    {
                        // Capturar y mostrar cualquier error ocurrido durante el proceso de actualización en BD.
                        MessageBox.Show($"Error al editar: {ex.Message}");
                    }
                }
            }
        }


        // Método asíncrono que muestra un cuadro de diálogo para confirmar la eliminación de un recordatorio.
        // Devuelve un Task<bool> que se completa con 'true' si el usuario confirma la eliminación,
        // o 'false' si cancela o cierra el diálogo sin confirmar.
        private async Task<bool> MostrarDialogoEliminacion()
        {
            // Llama a Show() de DialogHost para mostrar un diálogo modal en la UI.
            // El primer parámetro es el contenido inicial, aunque será reemplazado en el evento.
            // "MainDialogHost" es el identificador del contenedor donde se muestra el diálogo.
            var resultado = await MaterialDesignThemes.Wpf.DialogHost.Show(
                new TextBlock
                {
                    // Mensaje inicial en el diálogo (temporal)
                    Text = "¿Estás seguro de que deseas eliminar este recordatorio?",
                    TextWrapping = TextWrapping.Wrap,
                    Margin = new Thickness(20),
                    Width = 300
                },
                "MainDialogHost",

                // Esta función se ejecuta justo cuando el diálogo se abre para modificar el contenido.
                (object s, DialogOpenedEventArgs args) =>
                {
                    // Creamos un StackPanel vertical que contendrá el texto y los botones.
                    var dialogGrid = new StackPanel
                    {
                        Orientation = Orientation.Vertical,
                        Children =
                        {
                    // Texto de confirmación con fuente más grande y margen para separar del botón.
                    new TextBlock
                    {
                        Text = "¿Estás seguro de que deseas eliminar este recordatorio?",
                        FontSize = 16,
                        TextWrapping = TextWrapping.Wrap,
                        Margin = new Thickness(20, 20, 20, 16)
                    },

                    // Panel horizontal que contiene dos botones alineados a la derecha.
                    new StackPanel
                    {
                        Orientation = Orientation.Horizontal,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Children =
                        {
                            // Botón "Cancelar"
                            new Button
                            {
                                Content = "Cancelar", // Texto del botón
                                Margin = new Thickness(0, 20, 0, 20), // Margen para separación vertical
                                Foreground = Brushes.White, // Texto en blanco
                                Background = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#2C3E50")), // Color oscuro azul-grisáceo
                                Command = MaterialDesignThemes.Wpf.DialogHost.CloseDialogCommand, // Comando que cierra el diálogo
                                CommandParameter = false // Devuelve false cuando se pulsa este botón (indica cancelación)
                            },

                            // Botón "Eliminar"
                            new Button
                            {
                                Content = "Eliminar",
                                Margin = new Thickness(20, 20, 20, 20), // Margen para separación entre botones y vertical
                                Background = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#C0392B")), // Color rojo intenso
                                Foreground = Brushes.White, // Texto en blanco
                                Command = MaterialDesignThemes.Wpf.DialogHost.CloseDialogCommand, // Comando para cerrar diálogo
                                CommandParameter = true // Devuelve true cuando se pulsa este botón (indica confirmación)
                            }
                        }
                    }
                        }
                    };

                    // Reemplazamos el contenido original del diálogo por el StackPanel recién creado,
                    // así podemos tener un diseño con texto y botones personalizado.
                    args.Session.UpdateContent(dialogGrid);
                });

            // Al cerrar el diálogo, Show() devuelve un objeto con el parámetro que se pasó en CommandParameter.
            // Aquí comprobamos que sea un bool, y devolvemos true solo si el usuario confirmó (pulsó "Eliminar").
            return resultado is bool confirmado && confirmado;
        }


        // Método que elimina un recordatorio específico de la base de datos SQLite usando su ID.
        // Parámetro:
        //   id - Identificador único del recordatorio que se desea eliminar.
        //
        // El método establece una conexión segura con la base de datos, crea y ejecuta una
        // sentencia SQL para eliminar el registro correspondiente. Maneja errores mostrando 
        // un mensaje en caso de fallo, para que el usuario sepa si algo salió mal.
        private void EliminarRecordatorioDeBD(int id)
        {
            try
            {
                // Crea una conexión a la base de datos SQLite utilizando la cadena de conexión definida.
                using (var conn = new SQLiteConnection(connectionString))
                {
                    // Abre la conexión para permitir la ejecución de comandos SQL.
                    conn.Open();

                    // Construye un comando SQL parametrizado para eliminar el recordatorio cuyo ID coincida.
                    var cmd = new SQLiteCommand("DELETE FROM Recordatorios WHERE ID_Recordatorios = @id", conn);

                    // Asocia el parámetro @id con el valor del ID recibido para evitar inyección SQL.
                    cmd.Parameters.AddWithValue("@id", id);

                    // Ejecuta el comando de eliminación, afectando el registro en la base de datos.
                    cmd.ExecuteNonQuery();
                }
            }
            catch (Exception ex)
            {
                // Captura cualquier error ocurrido durante la conexión o ejecución y lo muestra al usuario.
                MessageBox.Show("Error al eliminar: " + ex.Message);
            }
        }

        // Muestra un mensaje temporal tipo "toast" con un ícono y texto personalizado en la interfaz.
        // El mensaje aparece con una animación de desvanecimiento, permanece visible unos segundos y luego desaparece con otra animación.
        // Parámetros:
        //   texto - El texto que se mostrará en el mensaje.
        //   icono - El nombre del archivo de imagen (ícono) que se mostrará junto al texto.
        // Método asíncrono que muestra un mensaje tipo "toast" en pantalla con un ícono y texto, 
        // el mensaje aparece con una animación de fade-in, permanece visible y luego desaparece con fade-out.
        private async void MostrarMensaje(string texto, string icono)
        {
            // Crea un contenedor visual de tipo Border que servirá como marco para el mensaje emergente.
            Border borde = new Border
            {
                // Establece un color de fondo personalizado (azul oscuro) para hacer que el mensaje resalte sobre la interfaz.
                Background = new SolidColorBrush(Color.FromRgb(44, 62, 80)),

                // Redondea las esquinas del borde para un diseño más amigable y moderno.
                CornerRadius = new CornerRadius(10),

                // Aplica un margen superior para separar este mensaje de otros que puedan estar en la lista.
                Margin = new Thickness(0, 5, 0, 0),

                // Añade un relleno interno para que el contenido no quede pegado al borde y tenga espacio para respirar.
                Padding = new Thickness(10),

                // Inicialmente el borde es invisible (opacidad 0) para luego animar su aparición con un efecto de fade-in.
                Opacity = 0,

                // Define el contenido interno del borde: un StackPanel horizontal que alinea el ícono y el texto lado a lado.
                Child = new StackPanel
                {
                    Orientation = Orientation.Horizontal,  // Los hijos se organizan en fila (ícono y texto).

                    Children =
        {
            // Imagen que representa el ícono del mensaje, se carga desde recursos embebidos en la aplicación.
            new Image
            {
                // Fuente de la imagen obtenida desde el paquete de la aplicación, usando el nombre de archivo recibido.
                Source = new BitmapImage(new Uri($"pack://application:,,,/Imagenes/{icono}", UriKind.Absolute)),

                // Tamaño fijo para mantener la uniformidad visual.
                Width = 24,
                Height = 24,

                // Margen derecho para separar el ícono del texto y mejorar la legibilidad.
                Margin = new Thickness(0, 0, 10, 0)
            },

            // Texto descriptivo del mensaje que se mostrará al usuario.
            new TextBlock
            {
                // Asigna el texto recibido como parámetro.
                Text = texto,

                // Color blanco para asegurar buen contraste y legibilidad sobre el fondo oscuro.
                Foreground = Brushes.White,

                // Centra verticalmente el texto en relación con el ícono.
                VerticalAlignment = VerticalAlignment.Center,

                // Tamaño de fuente cómodo para lectura.
                FontSize = 14,

                // Permite que el texto se ajuste en múltiples líneas si es muy largo.
                TextWrapping = TextWrapping.Wrap
            }
        }
                }
            };


            // Agrega el borde (mensaje) al panel visual que contiene todos los mensajes para que se muestre en la interfaz.
            StackMensajes.Children.Add(borde);

            // Define una animación de opacidad para hacer aparecer el mensaje suavemente (de 0 a 1 en 300ms).
            DoubleAnimation fadeIn = new DoubleAnimation(0, 1, TimeSpan.FromMilliseconds(300));
            borde.BeginAnimation(Border.OpacityProperty, fadeIn); // Inicia la animación de entrada

            // Espera 2.5 segundos para que el usuario pueda leer el mensaje antes de ocultarlo.
            await Task.Delay(2500);

            // Define una animación de opacidad para hacer desaparecer el mensaje (de 1 a 0 en 300ms).
            DoubleAnimation fadeOut = new DoubleAnimation(1, 0, TimeSpan.FromMilliseconds(300));

            // Cuando la animación de desaparición termine, elimina el borde del contenedor para liberar recursos y limpiar la UI.
            fadeOut.Completed += (s, e) => StackMensajes.Children.Remove(borde);

            // Inicia la animación de salida.
            borde.BeginAnimation(Border.OpacityProperty, fadeOut);
        }


    }
}
