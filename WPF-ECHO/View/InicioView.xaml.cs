// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System; Importa clases básicas del sistema como string, int, DateTime, Console, etc.
using System;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Collections.Generic; Permite el uso de colecciones genéricas como List<T>, Dictionary<K,V>, Queue<T>, etc.
using System.Collections.Generic;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Linq; Agrega soporte para LINQ, que permite hacer consultas sobre listas y colecciones de forma sencilla.
using System.Linq;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Text; Contiene clases para trabajar con texto, como StringBuilder o codificaciones (Encoding).
using System.Text;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Threading.Tasks; Habilita la programación asincrónica con async/await y la clase Task.
using System.Threading.Tasks;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows; Espacio base para aplicaciones WPF. Permite acceder a elementos principales como Application y Window.
using System.Windows;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Controls; Incluye controles visuales de WPF como Button, TextBox, Grid, ListView, etc.
using System.Windows.Controls;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Data; Permite crear y configurar el sistema de enlace de datos (data binding) entre la interfaz y los datos.
using System.Windows.Data;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Documents; Permite trabajar con documentos ricos en texto (como FlowDocument o TextRange).
using System.Windows.Documents;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Input; Habilita el uso de entradas del usuario, como eventos de teclado o mouse.
using System.Windows.Input;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Media; Proporciona clases gráficas como pinceles, colores, fuentes, degradados, etc.
using System.Windows.Media;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Media.Animation; Permite crear animaciones visuales como mover elementos, cambiar opacidad, rotar, etc.
using System.Windows.Media.Animation;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Media.Imaging; Ofrece clases para cargar y mostrar imágenes (como BitmapImage o ImageSource).
using System.Windows.Media.Imaging;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Navigation; Agrega la capacidad de navegar entre páginas dentro de la app WPF (como navegador web interno).
using System.Windows.Navigation;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Shapes; Proporciona formas geométricas básicas como Rectangle, Ellipse, Line, Path, etc.
using System.Windows.Shapes;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Data.SQLite; Permite conectarse y trabajar con bases de datos SQLite mediante ADO.NET.
using System.Data.SQLite;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Microsoft.Data.Sqlite; Alternativa moderna de conexión SQLite provista por Microsoft; más integrada con .NET actual.
using Microsoft.Data.Sqlite;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// ECHO.View; Importa las vistas (ventanas o páginas) definidas dentro del proyecto ECHO.
using ECHO.View;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// WPF_ECHO.ViewModels; Importa los ViewModels que se encuentran en una carpeta del proyecto ECHO, que forman parte del patrón MVVM (Modelo-Vista-VistaModelo).
using WPF_ECHO.ViewModels;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// IOPath = System.IO.Path; Crea un alias llamado IOPath para poder usar System.IO.Path sin confundirse con System.Windows.Shapes.Path.
using IOPath = System.IO.Path;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Threading; Proporciona acceso al temporizador del hilo principal para ejecutar acciones periódicas en WPF.
using System.Windows.Threading;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.IO; Permite acceder al sistema de archivos: leer, escribir, copiar, eliminar archivos o carpetas.
using System.IO;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// MaterialDesignThemes.Wpf; Importa los componentes de Material Design para aplicar estilos modernos a los controles WPF.
using MaterialDesignThemes.Wpf;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Controls.Primitives; Permite el uso de controles avanzados como Popup, Thumb, ToggleButton, etc.
using System.Windows.Controls.Primitives;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// CommunityToolkit.WinUI.Notifications; Permite crear y mostrar notificaciones nativas en Windows (toast notifications) estilo Windows 10/11.
using CommunityToolkit.WinUI.Notifications;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Globalization; Proporciona clases para trabajar con configuraciones culturales (idioma, formato de fecha, números, etc.).
using System.Globalization;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// ECHO.Recursos; Importa recursos personalizados (imágenes, estilos, textos, sonidos, etc.) definidos en el proyecto ECHO.
using ECHO.Recursos;


// La palabra clave "namespace" se utiliza para organizar y agrupar clases relacionadas bajo un mismo nombre lógico.
// Esto ayuda a evitar conflictos de nombres y mejora la organización del código.
// En este caso, el espacio de nombres se llama WPF_ECHO.View y contiene las vistas de la aplicación.
// Aparte el namespace puede ser llamado como el nombre del programa.
namespace WPF_ECHO.View
{
    /// <summary>
    /// Este comentario XML describe brevemente qué hace esta clase.
    /// Aquí indica que contiene la lógica de interacción del archivo InicioView.xaml.
    /// Esto se muestra como ayuda en el entorno de desarrollo (IntelliSense).
    /// </summary>

    // La palabra clave "public" indica que esta clase es accesible desde cualquier otro lugar del proyecto.
    // "partial" permite que la definición de esta clase esté dividida en varios archivos (por ejemplo, .xaml y .xaml.cs).
    // "class" define una nueva clase, que es un tipo de objeto que contiene datos y métodos.
    // "InicioView" es el nombre de la clase.
    // ": UserControl" significa que esta clase hereda de la clase UserControl,
    // lo cual le da funcionalidad visual y le permite comportarse como un control de interfaz de usuario reutilizable.
    public partial class InicioView : UserControl
    {
        // La palabra clave "public" indica que esta variable puede ser accedida desde fuera de esta clase.
        // "static" significa que pertenece a la clase en sí, no a una instancia específica.
        // "InicioView" es el tipo de dato, que coincide con el nombre de la clase.
        // "InstanciaActual" es el nombre de la variable, y se usará para acceder a la instancia actual de esta vista.
        public static InicioView InstanciaActual;

        // "private" significa que solo puede ser accedida dentro de esta clase.
        // "static readonly" indica que esta variable es constante durante la ejecución:
        // se asigna solo una vez y no puede modificarse luego.
        // "string" es el tipo de dato, una cadena de texto.
        // "connectionString" es el nombre de la variable.
        // Se le asigna el valor de la propiedad ConexionBD de la instancia de AppContexto.
        private static readonly string connectionString = AppContexto.Instancia.ConexionBD;

        // "private" restringe el acceso a esta variable a solo dentro de esta clase.
        // "bool" es el tipo de dato booleano (verdadero o falso).
        // "animacionEnCurso" es el nombre de la variable, y su valor inicial es "false".
        // Se usará para controlar si una animación se está ejecutando.
        private bool animacionEnCurso = false;

        // Constructor de la clase "InicioView". Se llama automáticamente cuando se crea un nuevo objeto de esta clase.
        public InicioView()
        {
            // Llama al método "InitializeComponent", que inicializa todos los componentes definidos en el archivo XAML asociado.
            // Esta llamada debe ir siempre primero para evitar errores al acceder a controles desde el código.
            InitializeComponent();

            // Declara una variable llamada "abrirAnim" de tipo Storyboard (una secuencia de animaciones).
            // Usa un recurso XAML llamado "VentanaAbrirAnimacion", lo busca en los recursos locales de esta vista,
            // y lo convierte (cast) a tipo Storyboard.
            Storyboard abrirAnim = (Storyboard)this.Resources["VentanaAbrirAnimacion"];

            // Inicia la animación obtenida en la línea anterior y la aplica a esta vista (this).
            abrirAnim.Begin(this);

            // Accede al TextBlock llamado "txtFechaActual" y le asigna la fecha actual.
            // DateTime.Now obtiene la fecha y hora actual.
            // ToString con el formato especificado muestra el día de la semana, número de día, mes y año.
            // "CultureInfo" se usa para que los nombres se muestren en español ("es-ES").
            CultureInfo cultura = new CultureInfo("es-DO");
            DateTime hoy = DateTime.Now;

            txtFechaActual.Text = $"{hoy.ToString("dddd", cultura)}, {hoy.Day} de {hoy.ToString("MMMM", cultura)} {hoy.Year}";


            // Asigna la instancia actual de esta clase (this) a la variable estática InstanciaActual.
            // Esto permite que otras clases accedan a esta vista sin necesidad de pasar una referencia.
            InstanciaActual = this;

            // Se suscribe al evento estático "RecordatorioDesdestacado" de la clase RecordatorioEventAggregator.
            // Cuando ese evento se dispare, se ejecutará el método OnRecordatorioDesdestacado.
            RecordatorioEventAggregator.RecordatorioDesdestacado += OnRecordatorioDesdestacado;

            // Se suscribe al evento "Loaded" de esta vista.
            // "Loaded" ocurre cuando la vista ha terminado de cargarse y sus elementos están listos.
            // Se le asigna el método InicioView_Loaded como manejador de eventos.
            this.Loaded += InicioView_Loaded;

            // Otra suscripción al evento "Loaded", pero esta vez con una expresión lambda.
            // Una lambda es una función anónima que se define directamente en línea.
            this.Loaded += (s, e) =>
            {
                // Dentro del lambda, se accede a la plantilla del control comboHoraMinuto,
                // y se busca un elemento interno llamado "PART_Popup" (nombre estándar para el popup de un ComboBox).
                // Si se encuentra y es de tipo Popup, se guarda en la variable popup.
                if (comboHoraMinuto.Template.FindName("PART_Popup", comboHoraMinuto) is Popup popup)
                {
                    // Se define que el Popup aparecerá debajo del control comboHoraMinuto.
                    popup.Placement = PlacementMode.Bottom;

                    // Se establece como objetivo de colocación el mismo comboHoraMinuto.
                    popup.PlacementTarget = comboHoraMinuto;

                    // Se define una función personalizada que ajusta la posición exacta del popup.
                    // Esta función se ejecuta cuando el sistema necesita mostrar el Popup.
                    popup.CustomPopupPlacementCallback = (popupSize, targetSize, offset) =>
                    {
                        // Se crea un punto de colocación en X=0 e Y=altura del control + 5 píxeles.
                        // Esto coloca el Popup ligeramente más abajo del control.
                        Point point = new Point(0, targetSize.Height + 5);

                        // Se devuelve un arreglo con una sola posición personalizada en el eje horizontal.
                        return new[] { new CustomPopupPlacement(point, PopupPrimaryAxis.Horizontal) };
                    };
                }
            };

            // Comentario aclaratorio indicando que aquí se puede inicializar la ruta de base de datos (si fuera necesario).
            // En este caso está vacío, pero sugiere que se puede hacer alguna acción en el constructor relacionada a la DB.
        }

        // Método público que puede ser llamado desde fuera de la clase.
        // "void" indica que este método no devuelve ningún valor.
        // El nombre "RecargarRecordatorios" sugiere que se usa para volver a cargar los recordatorios en la interfaz.
        public void RecargarRecordatorios()
        {
            // Llama a otro método de esta clase para cargar los recordatorios desde la base de datos.
            CargarRecordatoriosDesdeBD();
        }


        // Método privado que maneja el evento "Loaded" del control FondoImagen.
        // Este evento ocurre cuando el control ha sido completamente cargado y listo para interactuar.
        // Los parámetros: "object sender" representa el objeto que disparó el evento, y "RoutedEventArgs e" contiene datos del evento.
        private void FondoImagen_Loaded(object sender, RoutedEventArgs e)
        {
            // Verifica si los recursos de la aplicación contienen una imagen precargada bajo la clave "ImagenFondoPrecargada".
            if (Application.Current.Resources.Contains("ImagenFondoPrecargada"))
            {
                // Si existe, se establece como la imagen de fondo, haciendo un casting a BitmapImage.
                FondoImagen.Source = (BitmapImage)Application.Current.Resources["ImagenFondoPrecargada"];

                // Hace visible el control FondoImagen (por si estaba oculto).
                FondoImagen.Visibility = Visibility.Visible;
            }
        }


        // Declaración de una variable de tipo DispatcherTimer, que permite ejecutar tareas en intervalos de tiempo.
        // "DispatcherTimer" es útil para ejecutar código de forma periódica en el hilo de la interfaz (UI thread).
        DispatcherTimer timer;


        // Método privado que se ejecuta cuando la vista InicioView se ha cargado completamente (evento Loaded).
        // Igual que el anterior, recibe el remitente (sender) y los argumentos del evento (e).
        private void InicioView_Loaded(object sender, RoutedEventArgs e)
        {
            // Obtiene la animación llamada "VentanaAbrirAnimacion" desde los recursos de esta vista.
            Storyboard abrirAnim = (Storyboard)this.Resources["VentanaAbrirAnimacion"];

            // Inicia (ejecuta) la animación sobre el control actual (this).
            abrirAnim.Begin(this);

            // Limpia todos los controles hijos del panel "PanelRecordatorios".
            // Esto asegura que no haya recordatorios duplicados al recargar.
            PanelRecordatorios.Children.Clear();

            // Llama al método para cargar los recordatorios desde la base de datos y mostrarlos.
            CargarRecordatoriosDesdeBD();
        }


        // Método privado que se ejecuta cuando un recordatorio ha sido "desdestacado" (quitado de favoritos).
        // Recibe como parámetro un objeto "RecordatorioItem" que representa el control visual del recordatorio.
        private void OnRecordatorioDesdestacado(RecordatorioItem item)
        {
            // Obtiene el contenedor padre lógico del recordatorio (por ejemplo, un StackPanel).
            var parent = LogicalTreeHelper.GetParent(item) as Panel;

            // Verifica si el padre existe (no es null).
            if (parent != null)
            {
                // Remueve el recordatorio de su contenedor actual.
                parent.Children.Remove(item);
            }

            // Agrega el recordatorio al panel principal de recordatorios.
            PanelRecordatorios.Children.Add(item);
        }

        // Método que se ejecuta cuando el usuario hace clic en un botón.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // La palabra clave 'async' permite usar 'await' dentro del método para hacer tareas asincrónicas sin bloquear la interfaz.
        // 'void' indica que el método no devuelve ningún valor.
        // 'Button_Click' es el nombre del método, usualmente enlazado a un evento de clic.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.
        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            // Se verifica si ya hay una animación en ejecución.
            // Esto evita que se reproduzca otra animación mientras una anterior aún no termina.
            if (animacionEnCurso)
                return; // Sale del método si hay una animación en curso.

            // Se marca que hay una animación en proceso.
            // Esto bloquea la ejecución de otras animaciones hasta que termine.
            animacionEnCurso = true;

            // Se verifica si el contenedor donde se agregan los recordatorios está actualmente oculto.
            // 'Visibility.Visible' indica que el control es visible.
            if (ContenedorAddRecordatorio.Visibility != Visibility.Visible)
            {
                // Si el contenedor está oculto, se hace visible para mostrar el formulario de agregar recordatorio.
                ContenedorAddRecordatorio.Visibility = Visibility.Visible;

                // Se busca una animación llamada "SlideInFromRightAnimation" definida en los recursos XAML.
                // Esta animación hace que el contenedor aparezca desde la derecha.
                var slideIn = (Storyboard)FindResource("SlideInFromRightAnimation");

                // Se inicia la animación para mostrar el contenedor.
                slideIn.Begin(ContenedorAddRecordatorio);

                // Se espera de forma asincrónica 600 milisegundos (tiempo estimado de la animación).
                // 'await' permite que esta espera no congele la interfaz de usuario.
                await Task.Delay(600);
            }
            else
            {
                // Si el contenedor ya está visible, se prepara una animación para ocultarlo.
                // "SlideOutToRightAnimation" hace que el contenedor se desplace hacia la derecha y desaparezca.
                var slideOut = (Storyboard)FindResource("SlideOutToRightAnimation");

                // Se define lo que debe pasar cuando termine la animación de salida.
                // En este caso, se oculta el contenedor completamente cambiando su visibilidad a 'Collapsed'.
                slideOut.Completed += (s, ev) =>
                {
                    ContenedorAddRecordatorio.Visibility = Visibility.Collapsed;
                };

                // Se inicia la animación de salida del contenedor.
                slideOut.Begin(ContenedorAddRecordatorio);

                // Espera 600 milisegundos para dar tiempo a que termine la animación.
                await Task.Delay(600);
            }

            // Una vez que termina la animación (de entrada o salida), se marca que ya no hay animación en curso.
            // Esto permite que futuras interacciones con el botón sean posibles.
            animacionEnCurso = false;
        }

        // Método que se ejecuta al hacer clic en el botón de eliminar un recordatorio.
        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.

        private void BtnEliminar_Click(object sender, RoutedEventArgs e)
        {
            // Convierte el objeto 'sender' en un botón (Button).
            // 'as' devuelve null si la conversión falla.
            Button boton = sender as Button;

            // Si el botón no es null y su propiedad 'Tag' contiene un UIElement (como un RecordatorioItem)
            if (boton != null && boton.Tag is UIElement contenedor)
            {
                // Se elimina ese elemento del panel de recordatorios (lo quita visualmente de la vista).
                PanelRecordatorios.Children.Remove(contenedor);
            }
        }

        // Método asincrónico que se ejecuta cuando el usuario hace clic en el botón "Guardar".
        private async void btnGuardar_Click(object sender, RoutedEventArgs e)
        {
            // Se obtiene el texto ingresado por el usuario y se elimina cualquier espacio en blanco al inicio o final.
            string nota = txtNota.Text.Trim();

            // Se obtiene la fecha seleccionada en el DatePicker. Puede ser null si no se seleccionó ninguna.
            DateTime? fecha = fechaPicker.SelectedDate;

            // Se obtiene la hora seleccionada del selector personalizado. Puede ser null si no se seleccionó.
            TimeSpan? hora = comboHoraMinuto.SelectedTime?.TimeOfDay;

            // Bandera booleana que se usará para verificar si los datos son válidos.
            bool esValido = true;

            // -------- VALIDACIÓN DEL CAMPO TÍTULO --------
            if (string.IsNullOrEmpty(nota)) // Si el campo está vacío o nulo
            {
                ErrorTitulo.Visibility = Visibility.Visible; // Se muestra el mensaje de error
                ErrorTitulo.Text = "El título no puede quedar vacío.";
                esValido = false; // Se marca como inválido
            }
            else
            {
                ErrorTitulo.Visibility = Visibility.Collapsed; // Se oculta el error si todo está bien
            }

            // -------- VALIDACIÓN DE FECHA --------
            if (fecha == null)
            {
                ErrorFecha.Visibility = Visibility.Visible;
                ErrorFecha.Text = "Por favor selecciona una fecha.";
                esValido = false;
            }
            else if (fecha.Value.Date < DateTime.Today) // Si la fecha seleccionada es antes de hoy
            {
                ErrorFecha.Visibility = Visibility.Visible;
                ErrorFecha.Text = "La fecha no puede ser anterior al día de hoy.";
                esValido = false;
            }
            else
            {
                ErrorFecha.Visibility = Visibility.Collapsed;
            }

            // -------- VALIDACIÓN DE HORA --------
            if (hora == null)
            {
                ErrorHora.Visibility = Visibility.Visible;
                ErrorHora.Text = "Por favor selecciona una hora.";
                esValido = false;
            }
            else if (fecha.HasValue && fecha.Value.Date == DateTime.Today && hora.Value < DateTime.Now.TimeOfDay)
            {
                // Si la fecha es hoy y la hora es anterior a la actual, se rechaza.
                ErrorHora.Visibility = Visibility.Visible;
                ErrorHora.Text = "La hora seleccionada no puede ser anterior a la hora actual.";
                esValido = false;
            }
            else
            {
                ErrorHora.Visibility = Visibility.Collapsed;
            }

            // 🚫 Si hubo algún error de validación, se detiene la ejecución aquí.
            if (!esValido)
                return;

            // try se utiliza para cuando hace

            try
            {
                // Se establece una conexión con la base de datos SQLite.
                // `SQLiteConnection` es una clase que representa una conexión a una base de datos SQLite.
                // `connectionString` es una cadena de texto que contiene la información necesaria para conectarse (como la ruta del archivo .db).
                using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                {
                    connection.Open(); // Abre la conexión a la base de datos. Necesaria antes de ejecutar comandos SQL.

                    // ========== VERIFICACIÓN DE DUPLICADOS ==========

                    // Esta es una consulta SQL que cuenta cuántos registros ya existen con la misma fecha y hora.
                    string checkQuery = "SELECT COUNT(*) FROM Recordatorios WHERE Fecha = @Fecha AND Hora = @Hora";

                    // Se crea un comando SQL que se puede ejecutar en la base de datos.
                    // `SQLiteCommand` representa una instrucción SQL que se ejecutará usando una conexión abierta.
                    SQLiteCommand checkCommand = new SQLiteCommand(checkQuery, connection);

                    // Agrega los valores reales que reemplazarán los parámetros @Fecha y @Hora en la consulta.
                    // `Parameters.AddWithValue` es un método que asocia un valor a un parámetro dentro del SQL para evitar inyecciones SQL.
                    checkCommand.Parameters.AddWithValue("@Fecha", fecha.Value.ToString("yyyy-MM-dd")); // Formato de fecha: año-mes-día
                    checkCommand.Parameters.AddWithValue("@Hora", hora.Value.ToString(@"hh\:mm")); // Formato de hora: 08:30, 15:00, etc.

                    // Ejecuta la consulta y obtiene el número de filas que coinciden (puede ser 0 o más).
                    // `ExecuteScalar` devuelve el primer valor de la primera fila del resultado (en este caso, un número).
                    long existe = (long)checkCommand.ExecuteScalar();

                    // `if` es una estructura condicional que ejecuta código si se cumple la condición especificada.
                    if (existe > 0)
                    {
                        // Si existe al menos un recordatorio con la misma fecha y hora, se muestra un error.
                        ErrorHora.Visibility = Visibility.Visible;
                        ErrorHora.Text = "Ya existe un recordatorio para esa hora.";
                        return; // Se detiene el proceso aquí y no se guarda el nuevo recordatorio.
                    }

                    // ========== INSERCIÓN DEL NUEVO RECORDATORIO ==========

                    // Se crea una sentencia SQL para insertar un nuevo registro en la tabla Recordatorios.
                    string insertQuery = "INSERT INTO Recordatorios (Nota, Fecha, Hora) VALUES (@Nota, @Fecha, @Hora)";

                    // Se crea un nuevo comando SQL que ejecutará la inserción en la base de datos.
                    SQLiteCommand insertCommand = new SQLiteCommand(insertQuery, connection);

                    // Se asignan los valores reales a los parámetros dentro de la consulta SQL.
                    insertCommand.Parameters.AddWithValue("@Nota", nota); // Asigna el texto de la nota
                    insertCommand.Parameters.AddWithValue("@Fecha", fecha.Value.ToString("yyyy-MM-dd")); // Asigna la fecha seleccionada
                    insertCommand.Parameters.AddWithValue("@Hora", hora.Value.ToString(@"hh\:mm")); // Asigna la hora seleccionada

                    // Ejecuta el comando de inserción. `ExecuteNonQuery` devuelve el número de filas afectadas (insertadas).
                    int rowsAffected = insertCommand.ExecuteNonQuery();

                    // Se evalúa cuántas filas fueron insertadas. Si al menos una, el guardado fue exitoso.
                    if (rowsAffected > 0)
                    {
                        // Llama a funciones auxiliares que actualizan la interfaz del usuario.
                        LimpiarCampos(); // Limpia los campos del formulario
                        AgregarRecordatorio(nota, fecha.Value.ToShortDateString(), hora.Value.ToString(@"hh\:mm")); // Agrega visualmente el recordatorio
                        MostrarRecordatorioGuardado(); // Muestra un mensaje o animación de éxito
                        CargarRecordatoriosDesdeBD(); // Recarga todos los recordatorios guardados
                    }
                    else
                    {
                        // `else` se ejecuta si no se insertó ninguna fila (posible error).
                        MessageBox.Show("No se pudo guardar el recordatorio.");
                    }
                }
            }
            catch (Exception ex)
            {
                // Si ocurre un error en tiempo de ejecución (por ejemplo: base de datos corrupta, archivo bloqueado, etc.),
                // esta parte lo captura y se muestra un mensaje al usuario.

                // $"Error: {ex.Message}" crea un texto con el mensaje de error exacto.
                // ex.Message contiene el detalle técnico del error.
                MessageBox.Show($"Error: {ex.Message}");

                // Esto mostrará una ventana con el mensaje del sistema, por ejemplo:
                // "Error: No se puede abrir el archivo porque está en uso por otro proceso"
            }

            // await significa esperar, osea el usuario esperara que la funcion OcultarContenedorAddRecordatorio(); termine para seguir usando cualquier cosa
            // Oculta el panel de agregar recordatorio con animación.
            await OcultarContenedorAddRecordatorio();
        }


        private void LimpiarCampos() // Aqui limpiamos los datos despues de ser enviados
        {
            txtNota.Text = "";
            fechaPicker.SelectedDate = null;
            comboHoraMinuto.SelectedTime = null; // Desmarca cualquier selección
        }

        private void CargarRecordatoriosDesdeBD()
        {
            PanelRecordatorios.Children.Clear();

            try
            {
                using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                {
                    connection.Open();

                    // Filtra los recordatorios NO destacados
                    string selectQuery = "SELECT * FROM Recordatorios WHERE Destacado = 0 ORDER BY ID_Recordatorios DESC";
                    SQLiteCommand selectCommand = new SQLiteCommand(selectQuery, connection);

                    using (SQLiteDataReader reader = selectCommand.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            var item = new RecordatorioItem
                            {
                                ID_Recordatorios = Convert.ToInt32(reader["ID_Recordatorios"]),
                                Descripcion = reader["Nota"].ToString(),
                                Fecha = reader["Fecha"].ToString(),
                                Hora = reader["Hora"].ToString()
                            };

                            item.RecordatorioDestacadoEvent += RecordatorioDestacadoDesdeItem;
                            item.EliminarRecordatorio += Recordatorio_EliminarRecordatorio;
                            item.DataContext = item;

                            // Asignar evento de edición (solo si implementaste el evento EditarClicked en RecordatorioItem)
                            item.EditarClicked += (s, e) =>
                            {
                                EditarRecordatorio(item); // Asegúrate de tener este método implementado
                            };

                            PanelRecordatorios.Children.Add(item);

                        }
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error al acceder a la base de datos: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async void EditarRecordatorio(RecordatorioItem recordatorio)
        {

            var editarControl = new EditarRecordatorioDialog
            {
                IdRecordatorio = recordatorio.ID_Recordatorios
            };

            // Rellenar con los datos actuales
            editarControl.txtNotaEditar.Text = recordatorio.Descripcion;
            editarControl.fechaEditar.SelectedDate = DateTime.Parse(recordatorio.Fecha);
            TimeSpan hora = TimeSpan.Parse(recordatorio.Hora);  // Convierte el string a TimeSpan
            editarControl.horaEditar.SelectedTime = DateTime.Today.Add(hora);  // Suma el TimeSpan a DateTime.Today

            var resultado = await DialogHost.Show(editarControl, "MainDialogHost");

            if (resultado is "true")
            {
                // Obtener valores editados
                string nuevaNota = editarControl.txtNotaEditar.Text;
                DateTime? nuevaFecha = editarControl.fechaEditar.SelectedDate;
                TimeSpan? nuevaHora = editarControl.horaEditar.SelectedTime?.TimeOfDay;

                // Validaciones básicas (puedes mejorar)
                if (!string.IsNullOrWhiteSpace(nuevaNota) && nuevaFecha != null && nuevaHora != null)
                {
                    try
                    {
                        using (var conn = new SQLiteConnection(connectionString))
                        {
                            conn.Open();
                            var cmd = new SQLiteCommand("UPDATE Recordatorios SET Nota=@nota, Fecha=@fecha, Hora=@hora WHERE ID_Recordatorios=@id", conn);
                            cmd.Parameters.AddWithValue("@nota", nuevaNota);
                            cmd.Parameters.AddWithValue("@fecha", nuevaFecha.Value.ToString("yyyy-MM-dd"));
                            cmd.Parameters.AddWithValue("@hora", nuevaHora.Value.ToString(@"hh\:mm"));
                            cmd.Parameters.AddWithValue("@id", recordatorio.ID_Recordatorios);
                            cmd.ExecuteNonQuery();
                        }

                        MostrarMensaje("Recordatorio editado", "comprobado.png");
                        ActualizarRecordatorios();
                        CargarRecordatoriosDesdeBD();
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Error al editar: {ex.Message}");
                    }
                }
            }
        }


        // Agregar un nuevo recordatorio al PanelRecordatorios
        private void AgregarRecordatorio(string descripcion, string fecha, string hora)
        {
            var nuevoRecordatorio = new RecordatorioItem
            {
                Descripcion = descripcion,
                Fecha = fecha,
                Hora = hora
            };

            nuevoRecordatorio.DataContext = nuevoRecordatorio;

            // Suscribirse al evento de eliminación
            nuevoRecordatorio.EliminarRecordatorio += Recordatorio_EliminarRecordatorio;

            PanelRecordatorios.Children.Add(nuevoRecordatorio);
        }


        // Manejar el evento de eliminación
        private async void Recordatorio_EliminarRecordatorio(object sender, EventArgs e)
        {
            var recordatorio = sender as RecordatorioItem;
            if (recordatorio == null) return;

            var dialogResult = await MaterialDesignThemes.Wpf.DialogHost.Show(
                new TextBlock
                {
                    Text = "¿Estás seguro de que deseas eliminar este recordatorio?",
                    TextWrapping = TextWrapping.Wrap,
                    Margin = new Thickness(20),
                    Width = 300
                },
                "MainDialogHost",
                (object s, DialogOpenedEventArgs args) =>
                {
                    var dialogGrid = new StackPanel
                    {
                        Orientation = Orientation.Vertical,
                        Children =
                        {
                    new TextBlock
                    {
                        Text = "¿Estás seguro de que deseas eliminar este recordatorio?",
                        FontSize = 16,
                        TextWrapping = TextWrapping.Wrap,
                        Margin = new Thickness(20, 20, 20, 16)
                    },
                    new StackPanel
                    {
                        Orientation = Orientation.Horizontal,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Children =
                        {
                            new Button
                            {
                                Content = "Cancelar",
                                Margin = new Thickness(0,0,8,0),
                                Foreground = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#fff")),
                                Background = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#2C3E50")),
                                Command = MaterialDesignThemes.Wpf.DialogHost.CloseDialogCommand,
                                CommandParameter = false
                            },
                            new Button
                            {
                                Content = "Eliminar",
                                Margin = new Thickness (10,10,10,10),
                                Background = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#C0392B")),
                                Foreground = Brushes.White,
                                Command = MaterialDesignThemes.Wpf.DialogHost.CloseDialogCommand,
                                CommandParameter = true
                            }
                        }
                    }
                        }
                    };

                    args.Session.UpdateContent(dialogGrid);
                });

            if (dialogResult is bool confirmado && confirmado)
            {
                try
                {
                    using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                    {
                        connection.Open();

                        string deleteQuery = "DELETE FROM Recordatorios WHERE ID_Recordatorios = @ID";
                        SQLiteCommand deleteCommand = new SQLiteCommand(deleteQuery, connection);
                        deleteCommand.Parameters.AddWithValue("@ID", recordatorio.ID_Recordatorios);

                        deleteCommand.ExecuteNonQuery();
                    }

                    PanelRecordatorios.Children.Remove(recordatorio);
                    MostrarRecordatorioEliminado();
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error al eliminar el recordatorio: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }


        private void MostrarRecordatorioGuardado()
        {
            MostrarMensaje("Recordatorio añadido", "comprobado.png");
        }

        private void RecordatorioDestacadoDesdeItem(object sender, EventArgs e)
        {
            var item = sender as RecordatorioItem;
            if (item == null) return;

            // Actualizar en BD
            try
            {
                using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                {
                    connection.Open();
                    string updateQuery = "UPDATE Recordatorios SET Destacado = 1 WHERE ID_Recordatorios = @id";
                    using (var command = new SQLiteCommand(updateQuery, connection))
                    {
                        command.Parameters.AddWithValue("@id", item.ID_Recordatorios);
                        command.ExecuteNonQuery();
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error al destacar el recordatorio: {ex.Message}");
                return;
            }

            // Lanzar evento para que lo escuche DestacadoView
            RecordatorioEventAggregator.RaiseDestacadoToggled(item, true);

            // Mostrar el mensaje visual
            MostrarRecordatorioDestacado();
        }


        public void MostrarRecordatorioEliminado()
        {
            MostrarMensaje("Recordatorio eliminado", "eliminar.png");
        }

        private void MostrarRecordatorioDestacado()
        {
            MostrarMensaje("Recordatorio destacado", "EstrellaRellenada.png");

            CargarRecordatoriosDesdeBD();

        }

        /* Estos son los mensajes que te dicen cuando añadiste o eliminaste y destacaste un recordatorio */
        private async void MostrarMensaje(string texto, string icono)
        {
            // Crear contenedor del mensaje
            Border borde = new Border
            {
                Background = (Brush)new BrushConverter().ConvertFromString("#f4f4f4"),
                CornerRadius = new CornerRadius(10),
                Margin = new Thickness(0, 15, 0, 0),
                Padding = new Thickness(10),
                Opacity = 0,
                Child = new StackPanel
                {
                    Orientation = Orientation.Horizontal,
                    Children =
            {
                new Image
                {
                    Source = new BitmapImage(new Uri($"pack://application:,,,/Imagenes/{icono}", UriKind.Absolute)),
                    Width = 24,
                    Height = 24,
                    Margin = new Thickness(0,0,10,0)
                },
                new TextBlock
                {
                    Text = texto,
                    Foreground = Brushes.Black,
                    VerticalAlignment = VerticalAlignment.Center,
                    FontSize = 14,
                    TextWrapping = TextWrapping.Wrap
                }
            }
                }
            };

            StackMensajes.Children.Add(borde);

            // Animación de entrada (fade-in)
            DoubleAnimation fadeIn = new DoubleAnimation(0, 1, TimeSpan.FromMilliseconds(300));
            borde.BeginAnimation(Border.OpacityProperty, fadeIn);

            // Esperar 2.5 segundos
            await Task.Delay(2500);

            // Animación de salida (fade-out)
            DoubleAnimation fadeOut = new DoubleAnimation(1, 0, TimeSpan.FromMilliseconds(300));
            fadeOut.Completed += (s, e) => StackMensajes.Children.Remove(borde);
            borde.BeginAnimation(Border.OpacityProperty, fadeOut);
        }

        private async Task OcultarContenedorAddRecordatorio()
        {
            animacionEnCurso = true;

            var slideOut = (Storyboard)FindResource("SlideOutToRightAnimation");
            slideOut.Completed += (s, ev) =>
            {
                ContenedorAddRecordatorio.Visibility = Visibility.Collapsed;
            };
            slideOut.Begin(ContenedorAddRecordatorio);

            // Esperar también duración de la animación
            await Task.Delay(600);

            btnAbrirContenedor.IsEnabled = true;

            animacionEnCurso = false;
        }




        // Método para actualizar los recordatorios cuando se regresa a InicioView
        private void ActualizarRecordatorios()
        {
            // Limpiar los recordatorios previos
            PanelRecordatorios.Children.Clear();

            // Ahora, recargar los recordatorios desde la base de datos (separados por destacado o no)
            CargarRecordatoriosDesdeBD();  // Aquí puedes volver a llamar a tu método de carga.
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Button_Click(sender, e);
        }
    }
}