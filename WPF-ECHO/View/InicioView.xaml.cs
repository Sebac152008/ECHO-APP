// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System; Importa clases básicas del sistema como string, int, DateTime, Console, etc.
using System;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Collections.Generic; Permite el uso de colecciones genéricas como List<T>, Dictionary<K,V>, Queue<T>, etc.
using System.Collections.Generic;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Linq; Agrega soporte para LINQ, que permite hacer consultas sobre listas y colecciones de forma sencilla.
using System.Linq;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Text; Contiene clases para trabajar con texto, como StringBuilder o codificaciones (Encoding).
using System.Text;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Threading.Tasks; Habilita la programación asincrónica con async/await y la clase Task.
using System.Threading.Tasks;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows; Espacio base para aplicaciones WPF. Permite acceder a elementos principales como Application y Window.
using System.Windows;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Controls; Incluye controles visuales de WPF como Button, TextBox, Grid, ListView, etc.
using System.Windows.Controls;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Data; Permite crear y configurar el sistema de enlace de datos (data binding) entre la interfaz y los datos.
using System.Windows.Data;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Documents; Permite trabajar con documentos ricos en texto (como FlowDocument o TextRange).
using System.Windows.Documents;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Input; Habilita el uso de entradas del usuario, como eventos de teclado o mouse.
using System.Windows.Input;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Media; Proporciona clases gráficas como pinceles, colores, fuentes, degradados, etc.
using System.Windows.Media;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Media.Animation; Permite crear animaciones visuales como mover elementos, cambiar opacidad, rotar, etc.
using System.Windows.Media.Animation;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Media.Imaging; Ofrece clases para cargar y mostrar imágenes (como BitmapImage o ImageSource).
using System.Windows.Media.Imaging;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Navigation; Agrega la capacidad de navegar entre páginas dentro de la app WPF (como navegador web interno).
using System.Windows.Navigation;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Shapes; Proporciona formas geométricas básicas como Rectangle, Ellipse, Line, Path, etc.
using System.Windows.Shapes;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Data.SQLite; Permite conectarse y trabajar con bases de datos SQLite mediante ADO.NET.
using System.Data.SQLite;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// Microsoft.Data.Sqlite; Alternativa moderna de conexión SQLite provista por Microsoft; más integrada con .NET actual.
using Microsoft.Data.Sqlite;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// ECHO.View; Importa las vistas (ventanas o páginas) definidas dentro del proyecto ECHO.
using ECHO.View;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// WPF_ECHO.ViewModels; Importa los ViewModels que se encuentran en una carpeta del proyecto ECHO, que forman parte del patrón MVVM (Modelo-Vista-VistaModelo).
using WPF_ECHO.ViewModels;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// IOPath = System.IO.Path; Crea un alias llamado IOPath para poder usar System.IO.Path sin confundirse con System.Windows.Shapes.Path.
using IOPath = System.IO.Path;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Threading; Proporciona acceso al temporizador del hilo principal para ejecutar acciones periódicas en WPF.
using System.Windows.Threading;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.IO; Permite acceder al sistema de archivos: leer, escribir, copiar, eliminar archivos o carpetas.
using System.IO;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// MaterialDesignThemes.Wpf; Importa los componentes de Material Design para aplicar estilos modernos a los controles WPF.
using MaterialDesignThemes.Wpf;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Windows.Controls.Primitives; Permite el uso de controles avanzados como Popup, Thumb, ToggleButton, etc.
using System.Windows.Controls.Primitives;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// CommunityToolkit.WinUI.Notifications; Permite crear y mostrar notificaciones nativas en Windows (toast notifications) estilo Windows 10/11.
using CommunityToolkit.WinUI.Notifications;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// System.Globalization; Proporciona clases para trabajar con configuraciones culturales (idioma, formato de fecha, números, etc.).
using System.Globalization;

// La palabra clave "using" se utiliza para importar espacios de nombres (namespaces).
// Un espacio de nombres es un conjunto de clases, funciones y herramientas ya creadas
// que puedes usar en tu código sin tener que escribir su nombre completo.

// ECHO.Recursos; Importa recursos personalizados (imágenes, estilos, textos, sonidos, etc.) definidos en el proyecto ECHO.
using ECHO.Recursos;


// La palabra clave "namespace" se utiliza para organizar y agrupar clases relacionadas bajo un mismo nombre lógico.
// Esto ayuda a evitar conflictos de nombres y mejora la organización del código.
// En este caso, el espacio de nombres se llama WPF_ECHO.View y contiene las vistas de la aplicación.
// Aparte el namespace puede ser llamado como el nombre del programa.
namespace WPF_ECHO.View
{
    /// <summary>
    /// Este comentario XML describe brevemente qué hace esta clase.
    /// Aquí indica que contiene la lógica de interacción del archivo InicioView.xaml.
    /// Esto se muestra como ayuda en el entorno de desarrollo (IntelliSense).
    /// </summary>

    // La palabra clave "public" indica que esta clase es accesible desde cualquier otro lugar del proyecto.
    // "partial" permite que la definición de esta clase esté dividida en varios archivos (por ejemplo, .xaml y .xaml.cs).
    // "class" define una nueva clase, que es un tipo de objeto que contiene datos y métodos.
    // "InicioView" es el nombre de la clase.
    // ": UserControl" significa que esta clase hereda de la clase UserControl,
    // lo cual le da funcionalidad visual y le permite comportarse como un control de interfaz de usuario reutilizable.
    public partial class InicioView : UserControl
    {
        // La palabra clave "public" indica que esta variable puede ser accedida desde fuera de esta clase.
        // "static" significa que pertenece a la clase en sí, no a una instancia específica.
        // "InicioView" es el tipo de dato, que coincide con el nombre de la clase.
        // "InstanciaActual" es el nombre de la variable, y se usará para acceder a la instancia actual de esta vista.
        public static InicioView InstanciaActual;

        // "private" significa que solo puede ser accedida dentro de esta clase.
        // "static readonly" indica que esta variable es constante durante la ejecución:
        // se asigna solo una vez y no puede modificarse luego.
        // "string" es el tipo de dato, una cadena de texto.
        // "connectionString" es el nombre de la variable.
        // Se le asigna el valor de la propiedad ConexionBD de la instancia de AppContexto.
        private static readonly string connectionString = AppContexto.Instancia.ConexionBD;

        // "private" restringe el acceso a esta variable a solo dentro de esta clase.
        // "bool" es el tipo de dato booleano (verdadero o falso).
        // "animacionEnCurso" es el nombre de la variable, y su valor inicial es "false".
        // Se usará para controlar si una animación se está ejecutando.
        private bool animacionEnCurso = false;

        // La palabra clave "public" indica que esta que el constructor puede ser accedido desde fuera de esta clase.
        // Constructor de la clase "InicioView". Se llama automáticamente cuando se crea un nuevo objeto de esta clase.
        public InicioView()
        {
            // Llama al método "InitializeComponent", que inicializa todos los componentes definidos en el archivo XAML asociado.
            // Esta llamada debe ir siempre primero para evitar errores al acceder a controles desde el código.
            InitializeComponent();

            // Declara una variable llamada "abrirAnim" de tipo Storyboard (una secuencia de animaciones).
            // Usa un recurso XAML llamado "VentanaAbrirAnimacion", lo busca en los recursos locales de esta vista,
            // y lo convierte (cast) a tipo Storyboard.
            Storyboard abrirAnim = (Storyboard)this.Resources["VentanaAbrirAnimacion"];

            // Inicia la animación obtenida en la línea anterior y la aplica a esta vista (this).
            abrirAnim.Begin(this);

            // Accede al TextBlock llamado "txtFechaActual" y le asigna la fecha actual.
            // DateTime.Now obtiene la fecha y hora actual.
            // ToString con el formato especificado muestra el día de la semana, número de día, mes y año.
            // "CultureInfo" se usa para que los nombres se muestren en español ("es-ES").
            CultureInfo cultura = new CultureInfo("es-DO");
            DateTime hoy = DateTime.Now;

            txtFechaActual.Text = $"{hoy.ToString("dddd", cultura)}, {hoy.Day} de {hoy.ToString("MMMM", cultura)} {hoy.Year}";

            // this: significa esta vista
            // Asigna la instancia actual de esta clase (this) a la variable estática InstanciaActual.
            // Esto permite que otras clases accedan a esta vista sin necesidad de pasar una referencia.
            InstanciaActual = this;

            // Se suscribe al evento estático "RecordatorioDesdestacado" de la clase RecordatorioEventAggregator.
            // Cuando ese evento se dispare, se ejecutará el método OnRecordatorioDesdestacado.
            RecordatorioEventAggregator.RecordatorioDesdestacado += OnRecordatorioDesdestacado;

            // this: significa esta vista
            // Se suscribe al evento "Loaded" de esta vista (this).
            // "Loaded" ocurre cuando la vista ha terminado de cargarse y sus elementos están listos.
            // Se le asigna el método InicioView_Loaded como manejador de eventos.
            this.Loaded += InicioView_Loaded;

            // this: significa esta vista
            // Otra suscripción al evento "Loaded", pero esta vez con una expresión lambda.
            // Una lambda es una función anónima que se define directamente en línea.
            this.Loaded += (s, e) =>
            {
                // Dentro del lambda (una funcion sin nombre), se accede a la plantilla del control comboHoraMinuto,
                // y se busca un elemento interno llamado "PART_Popup" (nombre estándar para el popup de un ComboBox).
                // Si se encuentra y es de tipo Popup, se guarda en la variable popup.
                if (comboHoraMinuto.Template.FindName("PART_Popup", comboHoraMinuto) is Popup popup)
                {
                    // Se define que el Popup aparecerá debajo del control comboHoraMinuto.
                    popup.Placement = PlacementMode.Bottom;

                    // Se establece como objetivo de colocación el mismo comboHoraMinuto.
                    popup.PlacementTarget = comboHoraMinuto;

                    // Se define una función personalizada que ajusta la posición exacta del popup.
                    // Esta función se ejecuta cuando el sistema necesita mostrar el Popup.
                    popup.CustomPopupPlacementCallback = (popupSize, targetSize, offset) =>
                    {
                        // Se crea un punto de colocación en X=0 e Y=altura del control + 5 píxeles.
                        // Esto coloca el Popup ligeramente más abajo del control.
                        Point point = new Point(0, targetSize.Height + 5);

                        // Se devuelve un arreglo con una sola posición personalizada en el eje horizontal.
                        return new[] { new CustomPopupPlacement(point, PopupPrimaryAxis.Horizontal) };
                    };
                }
            };

            // Comentario aclaratorio indicando que aquí se puede inicializar la ruta de base de datos (si fuera necesario).
            // En este caso está vacío, pero sugiere que se puede hacer alguna acción en el constructor relacionada a la DB.
        }

        // Método público que puede ser llamado desde fuera de la clase.
        // "void" indica que este método no devuelve ningún valor.
        // El nombre "RecargarRecordatorios" sugiere que se usa para volver a cargar los recordatorios en la interfaz.
        public void RecargarRecordatorios()
        {
            // Llama a otro método de esta clase para cargar los recordatorios desde la base de datos.
            CargarRecordatoriosDesdeBD();
        }


        // Método privado que maneja el evento "Loaded" del control FondoImagen.
        // Este evento ocurre cuando el control ha sido completamente cargado y listo para interactuar.
        // Los parámetros: "object sender" representa el objeto que disparó el evento, y "RoutedEventArgs e" contiene datos del evento.
        private void FondoImagen_Loaded(object sender, RoutedEventArgs e)
        {
            // Verifica si los recursos de la aplicación contienen una imagen precargada bajo la clave "ImagenFondoPrecargada".
            if (Application.Current.Resources.Contains("ImagenFondoPrecargada"))
            {
                // Si existe, se establece como la imagen de fondo, haciendo un casting a BitmapImage.
                FondoImagen.Source = (BitmapImage)Application.Current.Resources["ImagenFondoPrecargada"];

                // Hace visible el control FondoImagen (por si estaba oculto).
                FondoImagen.Visibility = Visibility.Visible;
            }
        }


        // Declaración de una variable de tipo DispatcherTimer, que permite ejecutar tareas en intervalos de tiempo.
        // "DispatcherTimer" es útil para ejecutar código de forma periódica en el hilo de la interfaz (UI thread).
        DispatcherTimer timer;


        // Método privado que se ejecuta cuando la vista InicioView se ha cargado completamente (evento Loaded).
        // Igual que el anterior, recibe el remitente (sender) y los argumentos del evento (e).
        private void InicioView_Loaded(object sender, RoutedEventArgs e)
        {
            // Obtiene la animación llamada "VentanaAbrirAnimacion" desde los recursos de esta vista.
            Storyboard abrirAnim = (Storyboard)this.Resources["VentanaAbrirAnimacion"];

            // Inicia (ejecuta) la animación sobre el control actual (this).
            abrirAnim.Begin(this);

            // Limpia todos los controles hijos del panel "PanelRecordatorios".
            // Esto asegura que no haya recordatorios duplicados al recargar.
            PanelRecordatorios.Children.Clear();

            // Llama al método para cargar los recordatorios desde la base de datos y mostrarlos.
            CargarRecordatoriosDesdeBD();
        }


        // Método privado que se ejecuta cuando un recordatorio ha sido "desdestacado" (quitado de favoritos).
        // Recibe como parámetro un objeto "RecordatorioItem" que representa el control visual del recordatorio.
        private void OnRecordatorioDesdestacado(RecordatorioItem item)
        {
            // Obtiene el contenedor padre lógico del recordatorio (por ejemplo, un StackPanel).
            var parent = LogicalTreeHelper.GetParent(item) as Panel;

            // Verifica si el padre existe (no es null).
            if (parent != null)
            {
                // Remueve el recordatorio de su contenedor actual.
                parent.Children.Remove(item);
            }

            // Agrega el recordatorio al panel principal de recordatorios.
            PanelRecordatorios.Children.Add(item);
        }

        // Método que se ejecuta cuando el usuario hace clic en un botón.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // La palabra clave 'async' permite usar 'await' dentro del método para hacer tareas asincrónicas sin bloquear la interfaz.
        // 'void' indica que el método no devuelve ningún valor.
        // 'Button_Click' es el nombre del método, usualmente enlazado a un evento de clic.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.
        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            // Se verifica si ya hay una animación en ejecución.
            // Esto evita que se reproduzca otra animación mientras una anterior aún no termina.
            if (animacionEnCurso)
                return; // Sale del método si hay una animación en curso.

            // Se marca que hay una animación en proceso.
            // Esto bloquea la ejecución de otras animaciones hasta que termine.
            animacionEnCurso = true;

            // Se verifica si el contenedor donde se agregan los recordatorios está actualmente oculto.
            // 'Visibility.Visible' indica que el control es visible.
            if (ContenedorAddRecordatorio.Visibility != Visibility.Visible)
            {
                // Si el contenedor está oculto, se hace visible para mostrar el formulario de agregar recordatorio.
                ContenedorAddRecordatorio.Visibility = Visibility.Visible;

                // Se busca una animación llamada "SlideInFromRightAnimation" definida en los recursos XAML.
                // Esta animación hace que el contenedor aparezca desde la derecha.
                var slideIn = (Storyboard)FindResource("SlideInFromRightAnimation");

                // Se inicia la animación para mostrar el contenedor.
                slideIn.Begin(ContenedorAddRecordatorio);

                // Se espera de forma asincrónica 600 milisegundos (tiempo estimado de la animación).
                // 'await' permite que esta espera no congele la interfaz de usuario.
                await Task.Delay(600);
            }
            else
            {
                // Si el contenedor ya está visible, se prepara una animación para ocultarlo.
                // "SlideOutToRightAnimation" hace que el contenedor se desplace hacia la derecha y desaparezca.
                var slideOut = (Storyboard)FindResource("SlideOutToRightAnimation");

                // Se define lo que debe pasar cuando termine la animación de salida.
                // En este caso, se oculta el contenedor completamente cambiando su visibilidad a 'Collapsed'.
                slideOut.Completed += (s, ev) =>
                {
                    ContenedorAddRecordatorio.Visibility = Visibility.Collapsed;
                };

                // Se inicia la animación de salida del contenedor.
                slideOut.Begin(ContenedorAddRecordatorio);

                // Espera 600 milisegundos para dar tiempo a que termine la animación.
                await Task.Delay(600);
            }

            // Una vez que termina la animación (de entrada o salida), se marca que ya no hay animación en curso.
            // Esto permite que futuras interacciones con el botón sean posibles.
            animacionEnCurso = false;
        }

        // Método que se ejecuta al hacer clic en el botón de eliminar un recordatorio.
        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.

        // Método que se ejecuta cuando se hace clic en el botón 'BtnEliminar'.
        // 'sender' es el objeto que activó el evento, y 'e' contiene información del evento.
        private void BtnEliminar_Click(object sender, RoutedEventArgs e)
        {
            // Se intenta convertir el objeto 'sender' en un botón (Button) usando 'as'.
            // Si la conversión falla, 'boton' será null, lo que evita un error de ejecución.
            Button boton = sender as Button;

            // Se verifica que 'boton' no sea null y que su propiedad 'Tag' contenga un UIElement.
            // 'is' se usa para comprobar si 'Tag' es un tipo específico (UIElement).
            if (boton != null && boton.Tag is UIElement contenedor)
            {
                // Se elimina el elemento de 'PanelRecordatorios', eliminándolo visualmente de la interfaz de usuario.
                // 'Children.Remove()' quita el elemento del contenedor gráfico.
                PanelRecordatorios.Children.Remove(contenedor);
            }
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.
        // Método asincrónico que se ejecuta cuando el usuario hace clic en el botón "Guardar".
        private async void btnGuardar_Click(object sender, RoutedEventArgs e)
        {
            // Se obtiene el texto ingresado por el usuario y se elimina cualquier espacio en blanco al inicio o final usando el Trim().
            // txtNota.Text se utiliza para obtener el texto que se encuentra el bloque de texto Nota o Titulo del recordatorio ingresada por el usuario.
            // se crea una variable de tipo texto llamada nota que almacenara el Titulo del recordatorio.
            string nota = txtNota.Text.Trim();

            // Se obtiene la fecha seleccionada en el DatePicker. Puede ser null si no se seleccionó ninguna.
            DateTime? fecha = fechaPicker.SelectedDate;

            // Se obtiene la hora seleccionada del selector personalizado. Puede ser null si no se seleccionó.
            TimeSpan? hora = comboHoraMinuto.SelectedTime?.TimeOfDay;

            // Se crea una variable de tipo boleano (False and True / Falso o Verdadero)
            // Variable de tipo booleana que se usará para verificar si los datos son válidos.
            bool esValido = true;

            // -------- VALIDACIÓN DEL CAMPO TÍTULO --------
            // Se verifica si el usuario ha ingresado un título para el recordatorio.
            // 'string.IsNullOrEmpty()' comprueba si la cadena está vacía o nula.
            if (string.IsNullOrEmpty(nota))
            {
                // Se muestra un mensaje de error porque el título es un campo obligatorio.
                // 'Visibility.Visible' hace que el elemento de error sea visible en la interfaz gráfica.
                ErrorTitulo.Visibility = Visibility.Visible;

                // Se establece el mensaje que indica al usuario que debe ingresar un título.
                ErrorTitulo.Text = "El título no puede quedar vacío.";

                // La bandera 'esValido' se marca como falsa, lo que indica que hay un problema en la validación.
                esValido = false;
            }
            else
            {
                // Si el usuario ha ingresado un título válido, se oculta el mensaje de error.
                // 'Visibility.Collapsed' elimina el mensaje de error de la vista.
                ErrorTitulo.Visibility = Visibility.Collapsed;
            }

            // -------- VALIDACIÓN DE FECHA --------
            // Se verifica si el usuario ha seleccionado una fecha en el DatePicker.
            if (fecha == null)
            {
                // Se muestra el mensaje de error porque la fecha es un campo obligatorio.
                // ErrorFecha es un texto que muestra un error de Fecha
                // el .Visibiblity se utiliza para decidir se el texto se mostrara o se ocultara
                // En este caso el Visibility.Visible le dice al codigo que muestre el texto.
                ErrorFecha.Visibility = Visibility.Visible;

                // Se establece el mensaje de error indicando que el usuario debe seleccionar una fecha válida.
                ErrorFecha.Text = "Por favor selecciona una fecha.";

                // La bandera 'esValido' se marca como falsa porque falta información esencial.
                esValido = false;
            }
            else if (fecha.Value.Date < DateTime.Today)
            {
                // Si la fecha seleccionada es anterior a la fecha actual, se considera inválida.
                // No se permiten recordatorios para fechas en el pasado.
                ErrorFecha.Visibility = Visibility.Visible;

                // Se informa al usuario que la fecha debe ser igual o posterior a la fecha actual.
                ErrorFecha.Text = "La fecha no puede ser anterior al día de hoy.";

                // Se marca como inválido, ya que la fecha seleccionada no es aceptable.
                esValido = false;
            }
            else
            {
                // Si la fecha ingresada es válida, se oculta el mensaje de error.
                ErrorFecha.Visibility = Visibility.Collapsed;
            }

            // -------- VALIDACIÓN DE HORA --------
            // Se verifica si el usuario ha seleccionado una hora en el selector de tiempo.
            if (hora == null)
            {
                // Se muestra un mensaje de error porque el usuario no ha seleccionado una hora.
                // ErrorHora se utiliza para mostrar un error de hora al usuario.
                // Visibily hace que el texto se muestre o no se muestre.
                // el Visibility.Visible le dice al texto de error que se muestre.
                ErrorHora.Visibility = Visibility.Visible;

                // Se establece el mensaje de error indicando que la selección de hora es obligatoria.
                ErrorHora.Text = "Por favor selecciona una hora.";

                // Se marca como inválido, ya que la hora es un dato esencial.
                esValido = false;
            }
            else if (fecha.HasValue && fecha.Value.Date == DateTime.Today && hora.Value < DateTime.Now.TimeOfDay)
            {
                // Se verifica si la fecha ingresada es hoy y si la hora seleccionada es anterior a la hora actual.
                // No se permite programar recordatorios en el pasado.
                // ErrorHora se utiliza para mostrar un error de hora al usuario.
                // Visibily hace que el texto se muestre o no se muestre.
                // el Visibility.Visible le dice al texto de error que se muestre.
                ErrorHora.Visibility = Visibility.Visible;

                // Se muestra un mensaje de error explicando que no se puede elegir una hora anterior a la actual.
                ErrorHora.Text = "La hora seleccionada no puede ser anterior a la hora actual.";

                // Se marca como inválido porque la hora elegida es incorrecta.
                esValido = false;
            }
            else
            {
                // Si la hora es válida, se oculta el mensaje de error para mostrar un formulario limpio.
                // ErrorHora se utiliza para mostrar un error de hora al usuario.
                // Visibily hace que el texto se muestre o no se muestre.
                // el Visibility.Visible le dice al texto de error que se muestre.
                ErrorHora.Visibility = Visibility.Collapsed;
            }

            // 🚫 Si hubo algún error de validación, se detiene la ejecución del código antes de continuar.
            if (!esValido)
                return;

            // try se utiliza para cuando hace

            try
            {
                // Se establece una conexión con la base de datos SQLite.
                // `SQLiteConnection` es una clase que representa una conexión a una base de datos SQLite.
                // `connectionString` es una cadena de texto que contiene la información necesaria para conectarse (como la ruta del archivo .db).
                using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                {
                    connection.Open(); // Abre la conexión a la base de datos. Necesaria antes de ejecutar comandos SQL.

                    // ========== VERIFICACIÓN DE DUPLICADOS ==========

                    // Esta es una consulta SQL que cuenta cuántos registros ya existen con la misma fecha y hora.
                    string checkQuery = "SELECT COUNT(*) FROM Recordatorios WHERE Fecha = @Fecha AND Hora = @Hora";

                    // Se crea un comando SQL que se puede ejecutar en la base de datos.
                    // `SQLiteCommand` representa una instrucción SQL que se ejecutará usando una conexión abierta.
                    SQLiteCommand checkCommand = new SQLiteCommand(checkQuery, connection);

                    // Agrega los valores reales que reemplazarán los parámetros @Fecha y @Hora en la consulta.
                    // `Parameters.AddWithValue` es un método que asocia un valor a un parámetro dentro del SQL para evitar inyecciones SQL.
                    checkCommand.Parameters.AddWithValue("@Fecha", fecha.Value.ToString("yyyy-MM-dd")); // Formato de fecha: año-mes-día
                    checkCommand.Parameters.AddWithValue("@Hora", hora.Value.ToString(@"hh\:mm")); // Formato de hora: 08:30, 15:00, etc.

                    // Ejecuta la consulta y obtiene el número de filas que coinciden (puede ser 0 o más).
                    // `ExecuteScalar` devuelve el primer valor de la primera fila del resultado (en este caso, un número).
                    long existe = (long)checkCommand.ExecuteScalar();

                    // `if` es una estructura condicional que ejecuta código si se cumple la condición especificada.
                    if (existe > 0)
                    {
                        // Si existe al menos un recordatorio con la misma fecha y hora, se muestra un error.
                        // ErrorHora se utiliza para mostrar un error de hora al usuario.
                        // Visibily hace que el texto se muestre o no se muestre.
                        // el Visibility.Visible le dice al texto de error que se muestre.
                        ErrorHora.Visibility = Visibility.Visible;
                        // en esta parte le decimos cual va hacer el texto que va a tener el label o texto de error de hora
                        ErrorHora.Text = "Ya existe un recordatorio para esa hora.";
                        return; // Se detiene el proceso aquí y no se guarda el nuevo recordatorio.
                    }

                    // ========== INSERCIÓN DEL NUEVO RECORDATORIO ==========

                    // Se crea una sentencia SQL para insertar un nuevo registro en la tabla Recordatorios.
                    string insertQuery = "INSERT INTO Recordatorios (Nota, Fecha, Hora) VALUES (@Nota, @Fecha, @Hora)";

                    // Se crea un nuevo comando SQL que ejecutará la inserción en la base de datos.
                    SQLiteCommand insertCommand = new SQLiteCommand(insertQuery, connection);

                    // Se asignan los valores reales a los parámetros dentro de la consulta SQL.
                    insertCommand.Parameters.AddWithValue("@Nota", nota); // Asigna el texto de la nota
                    insertCommand.Parameters.AddWithValue("@Fecha", fecha.Value.ToString("yyyy-MM-dd")); // Asigna la fecha seleccionada
                    insertCommand.Parameters.AddWithValue("@Hora", hora.Value.ToString(@"hh\:mm")); // Asigna la hora seleccionada

                    // Ejecuta el comando de inserción. `ExecuteNonQuery` devuelve el número de filas afectadas (insertadas).
                    int rowsAffected = insertCommand.ExecuteNonQuery();

                    // Se evalúa cuántas filas fueron insertadas. Si al menos una, el guardado fue exitoso.
                    // operador de mañor que, en este if o si, lo que hacemos es que si la variable de tipo entero llamada rowsAffected,
                    // es mañor que 0 ejecuta el siguiente codigo, sino entonces sigue o ejecuta el "else"
                    if (rowsAffected > 0)
                    {
                        // Llama a funciones auxiliares que actualizan la interfaz del usuario.
                        LimpiarCampos(); // Limpia los campos del formulario
                        AgregarRecordatorio(nota, fecha.Value.ToShortDateString(), hora.Value.ToString(@"hh\:mm")); // Agrega visualmente el recordatorio
                        MostrarRecordatorioGuardado(); // Muestra un mensaje o animación de éxito
                        CargarRecordatoriosDesdeBD(); // Recarga todos los recordatorios guardados
                    }

                    // `else` se ejecuta si no se insertó ninguna fila (posible error).
                    else
                    {
                        MessageBox.Show("No se pudo guardar el recordatorio.");
                    }
                }
            }
            catch (Exception ex)
            {
                // Si ocurre un error en tiempo de ejecución (por ejemplo: base de datos corrupta, archivo bloqueado, etc.),
                // esta parte lo captura y se muestra un mensaje al usuario.

                // $"Error: {ex.Message}" crea un texto con el mensaje de error exacto.
                // ex.Message contiene el detalle técnico del error.
                MessageBox.Show($"Error: {ex.Message}");

                // Esto mostrará una ventana con el mensaje del sistema, por ejemplo:
                // "Error: No se puede abrir el archivo porque está en uso por otro proceso"
            }

            // await significa esperar, osea el usuario esperara que la funcion OcultarContenedorAddRecordatorio(); termine para seguir usando cualquier cosa
            // Oculta el panel de agregar recordatorio con animación.
            await OcultarContenedorAddRecordatorio();
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.
        // Método que se encarga de limpiar los campos del formulario después de enviar los datos.
        // Esto garantiza que los valores anteriores no queden visibles y permite al usuario ingresar nueva información.
        private void LimpiarCampos()
        {
            // Se vacía el campo de texto donde el usuario ingresó la nota.
            // Asignar una cadena vacía ("") borra el contenido del control de texto.
            txtNota.Text = "";

            // Se restablece la selección de fecha en el DatePicker a 'null'.
            // Esto elimina cualquier fecha previamente seleccionada, dejando el campo vacío.
            fechaPicker.SelectedDate = null;

            // Se elimina la selección de hora en el control de tiempo.
            // Al asignar 'null', se desmarca cualquier selección previa en el selector de hora y minutos.
            comboHoraMinuto.SelectedTime = null;
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // Método que carga los recordatorios almacenados en la base de datos SQLite
        private void CargarRecordatoriosDesdeBD()
        {
            // Se limpia el panel de recordatorios antes de cargar los nuevos datos.
            // Esto evita duplicaciones al refrescar los elementos en la interfaz gráfica.
            PanelRecordatorios.Children.Clear();

            try
            {
                // Se establece una conexión con la base de datos SQLite dentro de un bloque 'using'.
                // Esto garantiza que la conexión se cierre automáticamente al finalizar la ejecución.
                using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                {
                    connection.Open(); // Se abre la conexión con la base de datos.

                    // -------- CONSULTA SQL PARA OBTENER RECORDATORIOS --------
                    // Se define una consulta SQL que selecciona todos los recordatorios que no están marcados como "Destacados".
                    // Se ordenan en orden descendente según el ID para mostrar los más recientes primero.
                    string selectQuery = "SELECT * FROM Recordatorios WHERE Destacado = 0 ORDER BY ID_Recordatorios DESC";

                    // Se crea un comando SQL para ejecutar la consulta.
                    SQLiteCommand selectCommand = new SQLiteCommand(selectQuery, connection);

                    // Se ejecuta el comando y se obtiene un lector de datos para recorrer los resultados.
                    using (SQLiteDataReader reader = selectCommand.ExecuteReader())
                    {
                        // Se recorre cada fila obtenida de la base de datos.
                        while (reader.Read())
                        {
                            // Se crea un nuevo objeto de tipo 'RecordatorioItem' con los datos obtenidos de la base de datos.
                            var item = new RecordatorioItem
                            {
                                // Se asigna el ID del recordatorio, convirtiéndolo a un entero.
                                ID_Recordatorios = Convert.ToInt32(reader["ID_Recordatorios"]),

                                // Se asigna la descripción del recordatorio.
                                Descripcion = reader["Nota"].ToString(),

                                // Se obtiene la fecha del recordatorio almacenada en la base de datos.
                                Fecha = reader["Fecha"].ToString(),

                                // Se obtiene la hora asociada al recordatorio.
                                Hora = reader["Hora"].ToString()
                            };

                            // Se suscriben eventos para manejar acciones específicas en el recordatorio.
                            item.RecordatorioDestacadoEvent += RecordatorioDestacadoDesdeItem; // Evento de destacar el recordatorio
                            item.EliminarRecordatorio += Recordatorio_EliminarRecordatorio; // Evento de eliminación

                            // Se asigna el objeto como contexto de datos para su uso en la interfaz.
                            item.DataContext = item;

                            // -------- EVENTO PARA EDITAR RECORDATORIO --------
                            // Se asigna el evento de edición del recordatorio si está implementado en 'RecordatorioItem'.
                            item.EditarClicked += (s, e) =>
                            {
                                EditarRecordatorio(item); // Método para editar el recordatorio seleccionado
                            };

                            // Se agrega el recordatorio al panel de recordatorios en la interfaz gráfica.
                            // panel recordatorio es donde se encuentra cada recordatorio
                            // en este codigo lo que se hace es añadir el nuevo recordatorio al panel recordatorios
                            PanelRecordatorios.Children.Add(item);
                        }
                    }
                }
            }

            // Catch se utiliza para cuando al intentar acceder al base de datos fue fallida entonces muestra un mensaje o excesion (Exception) de error
            // Ese mensaje de error lo convertimos a una variable llamada ex que tendra el valor de Exception
            catch (Exception ex)
            {
                // Si ocurre un error al acceder a la base de datos, se captura y se muestra un mensaje de error al usuario.
                MessageBox.Show($"Error al acceder a la base de datos: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.
        // Método asincrónico que permite editar un recordatorio existente en la base de datos.
        // La palabra clave 'async' permite usar 'await' dentro del método para hacer tareas asincrónicas sin bloquear la interfaz.
        private async void EditarRecordatorio(RecordatorioItem recordatorio)
        {
            // Se crea una instancia del diálogo de edición de recordatorios.
            var editarControl = new EditarRecordatorioDialog
            {
                // Se asigna el ID del recordatorio que se está editando.
                IdRecordatorio = recordatorio.ID_Recordatorios
            };

            // -------- Rellenar los campos del diálogo con los datos actuales del recordatorio --------
            // Se establece el texto de la nota con la descripción actual del recordatorio.
            editarControl.txtNotaEditar.Text = recordatorio.Descripcion;

            // Se convierte el valor de fecha almacenado en formato de cadena a tipo DateTime y se asigna al campo de fecha.
            editarControl.fechaEditar.SelectedDate = DateTime.Parse(recordatorio.Fecha);

            // Se convierte el valor de la hora de texto a tipo TimeSpan.
            TimeSpan hora = TimeSpan.Parse(recordatorio.Hora);

            // Se asigna la hora seleccionada sumándola a la fecha actual (para mantener el formato correcto en el selector de hora).
            editarControl.horaEditar.SelectedTime = DateTime.Today.Add(hora);

            // Se muestra el diálogo de edición de recordatorio y se espera la acción del usuario.
            var resultado = await DialogHost.Show(editarControl, "MainDialogHost");

            // -------- Validación de la confirmación de edición --------
            // Se verifica si el usuario confirmó la edición del recordatorio (si el resultado es "true").
            if (resultado is "true")
            {
                // Se obtienen los nuevos valores ingresados por el usuario en el formulario de edición.
                string nuevaNota = editarControl.txtNotaEditar.Text;
                DateTime? nuevaFecha = editarControl.fechaEditar.SelectedDate;
                TimeSpan? nuevaHora = editarControl.horaEditar.SelectedTime?.TimeOfDay;

                // -------- Validaciones básicas antes de actualizar la base de datos --------
                // Se verifica que los valores ingresados sean válidos antes de realizar la actualización.
                if (!string.IsNullOrWhiteSpace(nuevaNota) && nuevaFecha != null && nuevaHora != null)
                {
                    try
                    {
                        // Se establece una conexión con la base de datos SQLite dentro de un bloque 'using'.
                        // Esto garantiza que la conexión se cierre automáticamente al finalizar la operación.
                        using (var conn = new SQLiteConnection(connectionString))
                        {
                            conn.Open(); // Se abre la conexión con la base de datos.

                            // Se define una consulta SQL para actualizar el recordatorio en la base de datos.
                            var cmd = new SQLiteCommand("UPDATE Recordatorios SET Nota=@nota, Fecha=@fecha, Hora=@hora WHERE ID_Recordatorios=@id", conn);

                            // Se asignan los valores editados a los parámetros de la consulta SQL.
                            cmd.Parameters.AddWithValue("@nota", nuevaNota);
                            cmd.Parameters.AddWithValue("@fecha", nuevaFecha.Value.ToString("yyyy-MM-dd")); // Se formatea la fecha en formato Año-Mes-Día.
                            cmd.Parameters.AddWithValue("@hora", nuevaHora.Value.ToString(@"hh\:mm")); // Se formatea la hora en formato HH:MM.
                            cmd.Parameters.AddWithValue("@id", recordatorio.ID_Recordatorios); // Se asigna el ID del recordatorio a actualizar.

                            // Se ejecuta la consulta SQL para actualizar el recordatorio en la base de datos.
                            cmd.ExecuteNonQuery();
                        }

                        // Se muestra un mensaje indicando que el recordatorio fue editado correctamente.
                        MostrarMensaje("Recordatorio editado", "comprobado.png");

                        // Se actualiza la lista de recordatorios en la interfaz de usuario.
                        ActualizarRecordatorios();

                        // Se recarga la lista de recordatorios desde la base de datos para reflejar los cambios.
                        CargarRecordatoriosDesdeBD();
                    }
                    catch (Exception ex)
                    {
                        // Si ocurre un error durante la actualización, se captura y se muestra un mensaje de error al usuario.
                        MessageBox.Show($"Error al editar: {ex.Message}");
                    }
                }
            }
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.
        // Agregar un nuevo recordatorio al PanelRecordatorios
        // este metodo tiene los parametros osea valores que deben ser añadidos para su funcionamiento que seran las variables descripcion, fecha, hora.
        // Método que agrega un nuevo recordatorio a la interfaz de usuario.
        // Se le pasan la descripción, fecha y hora del recordatorio como parámetros.
        private void AgregarRecordatorio(string descripcion, string fecha, string hora)
        {
            // Se crea una nueva instancia de 'RecordatorioItem' que representará el recordatorio en la interfaz.
            var nuevoRecordatorio = new RecordatorioItem
            {
                // Se asigna la descripción del recordatorio.
                Descripcion = descripcion,

                // Se asigna la fecha en formato de cadena.
                Fecha = fecha,

                // Se asigna la hora en formato de cadena.
                Hora = hora
            };

            // Se establece el contexto de datos para que los valores del objeto 'nuevoRecordatorio'
            // puedan ser utilizados correctamente dentro de la interfaz gráfica.
            nuevoRecordatorio.DataContext = nuevoRecordatorio;

            // -------- SUSCRIPCIÓN A EVENTOS --------
            // Se suscribe el evento 'EliminarRecordatorio', que permite eliminar el recordatorio desde la interfaz.
            nuevoRecordatorio.EliminarRecordatorio += Recordatorio_EliminarRecordatorio;

            // Se añade el nuevo recordatorio al panel de recordatorios en la interfaz gráfica.
            PanelRecordatorios.Children.Add(nuevoRecordatorio);
        }


        // Manejar el evento de eliminación
        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'EventArgs e' contiene información adicional sobre el evento de clic.
        // La palabra clave 'async' permite usar 'await' dentro del método para hacer tareas asincrónicas sin bloquear la interfaz.
        // Método asincrónico que maneja la eliminación de un recordatorio.
        // Se ejecuta cuando el usuario activa la acción de eliminar un recordatorio desde la interfaz.
        private async void Recordatorio_EliminarRecordatorio(object sender, EventArgs e)
        {
            // Se intenta convertir 'sender' en un objeto de tipo 'RecordatorioItem'.
            // 'sender' es el origen del evento, y con 'as' verificamos si realmente es del tipo esperado.
            var recordatorio = sender as RecordatorioItem;

            // Si la conversión falla y 'recordatorio' es null, se termina la ejecución del método sin hacer nada más.
            if (recordatorio == null) return;

            // -------- DIÁLOGO DE CONFIRMACIÓN --------
            // Antes de eliminar el recordatorio, se muestra un cuadro de diálogo para preguntar al usuario si está seguro de la acción.
            var dialogResult = await MaterialDesignThemes.Wpf.DialogHost.Show(
                new TextBlock
                {
                    Text = "¿Estás seguro de que deseas eliminar este recordatorio?", // Mensaje de confirmación
                    TextWrapping = TextWrapping.Wrap, // Ajusta el texto si es muy largo
                    Margin = new Thickness(20), // Establece márgenes alrededor del texto para mejor visualización
                    Width = 300 // Define el ancho del cuadro de diálogo
                },
                "MainDialogHost",
                (object s, DialogOpenedEventArgs args) =>
                {
                    // Se crea una estructura visual para el diálogo, con el mensaje y los botones de confirmación.
                    var dialogGrid = new StackPanel
                    {
                        Orientation = Orientation.Vertical, // Organiza los elementos en columna
                        Children =
                        {
                    // Texto explicativo dentro del cuadro de diálogo
                    new TextBlock
                    {
                        // texto que se mostrara
                        Text = "¿Estás seguro de que deseas eliminar este recordatorio?",
                        FontSize = 16, // Tamaño de fuente adecuado para la lectura
                        TextWrapping = TextWrapping.Wrap, // Permite que el texto se acomode en varias líneas
                        Margin = new Thickness(20, 20, 20, 16) // Márgenes para mejorar la presentación
                    },
                    // Contenedor de botones para aceptar o cancelar la acción
                    new StackPanel
                    {
                        Orientation = Orientation.Horizontal, // Alinea los botones en fila
                        HorizontalAlignment = HorizontalAlignment.Right, // Alinea los botones a la derecha
                        Children =
                        {
                            // Botón para cancelar la eliminación y cerrar el cuadro de diálogo sin ejecutar cambios
                            new Button
                            {
                                Content = "Cancelar",
                                Margin = new Thickness(0, 0, 8, 0),
                                Foreground = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#fff")), // Color del texto
                                Background = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#2C3E50")), // Color de fondo
                                Command = MaterialDesignThemes.Wpf.DialogHost.CloseDialogCommand, // Cierra el diálogo
                                CommandParameter = false // Indica que el usuario no confirmó la eliminación
                            },
                            // Botón para confirmar la eliminación del recordatorio
                            new Button
                            {
                                Content = "Eliminar",
                                Margin = new Thickness(10, 10, 10, 10),
                                Background = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#C0392B")), // Color rojo de eliminación
                                Foreground = Brushes.White, // Texto en color blanco
                                Command = MaterialDesignThemes.Wpf.DialogHost.CloseDialogCommand, // Cierra el diálogo
                                CommandParameter = true // Indica que el usuario confirmó la eliminación
                            }
                        }
                    }
                        }
                    };

                    // Se actualiza el contenido del cuadro de diálogo con el diseño personalizado.
                    args.Session.UpdateContent(dialogGrid);
                });

            // -------- PROCESO DE ELIMINACIÓN --------
            // Se verifica si el usuario confirmó la eliminación (si 'dialogResult' es 'true').
            if (dialogResult is bool confirmado && confirmado)
            {
                try
                {
                    // Se establece una conexión con la base de datos SQLite dentro de un bloque 'using'.
                    // Esto garantiza que la conexión se cierre automáticamente después de la operación.
                    using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                    {
                        connection.Open(); // Se abre la conexión con la base de datos

                        // Se define la consulta SQL para eliminar el recordatorio con el ID específico.
                        string deleteQuery = "DELETE FROM Recordatorios WHERE ID_Recordatorios = @ID";

                        // Se crea el comando SQL para ejecutar la eliminación.
                        SQLiteCommand deleteCommand = new SQLiteCommand(deleteQuery, connection);

                        // Se asigna el valor del ID del recordatorio al parámetro '@ID' en la consulta SQL.
                        deleteCommand.Parameters.AddWithValue("@ID", recordatorio.ID_Recordatorios);

                        // Se ejecuta la consulta SQL para eliminar el recordatorio de la base de datos.
                        deleteCommand.ExecuteNonQuery();
                    }

                    // Se elimina el recordatorio de la interfaz gráfica para que ya no se muestre en pantalla.
                    PanelRecordatorios.Children.Remove(recordatorio);

                    // Se muestra un mensaje indicando que el recordatorio ha sido eliminado correctamente.
                    MostrarRecordatorioEliminado();
                }
                catch (Exception ex)
                {
                    // Si ocurre un error en el proceso de eliminación, se captura y se muestra un mensaje de error al usuario.
                    // el messagebox es para mostrar un mensaje de dialogo
                    MessageBox.Show($"Error al eliminar el recordatorio: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // Método que muestra una notificación visual indicando que un recordatorio ha sido guardado exitosamente.
        private void MostrarRecordatorioGuardado()
        {
            // Se llama a la función 'MostrarMensaje' para desplegar un mensaje en la interfaz.
            // El primer parámetro es el texto del mensaje, indicando que el recordatorio ha sido añadido.
            // El segundo parámetro es el nombre de la imagen que se mostrará junto al mensaje, en este caso, un ícono de verificación.
            MostrarMensaje("Recordatorio añadido", "comprobado.png");
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'EventArgs e' contiene información adicional sobre el evento de clic.
        // Método que marca un recordatorio como "Destacado".
        // Se ejecuta cuando un usuario activa la opción para destacar un recordatorio.
        private void RecordatorioDestacadoDesdeItem(object sender, EventArgs e)
        {
            // Se intenta convertir 'sender' en un objeto de tipo 'RecordatorioItem'.
            // 'sender' es el origen del evento, y con 'as' verificamos si es del tipo esperado.
            var item = sender as RecordatorioItem;

            // Si la conversión falla y 'item' es null, se termina la ejecución del método sin realizar cambios.
            if (item == null) return;

            // -------- ACTUALIZAR EL RECORDATORIO EN LA BASE DE DATOS --------
            try
            {
                // Se establece una conexión con la base de datos SQLite dentro de un bloque 'using'.
                // Esto garantiza que la conexión se cierre automáticamente al finalizar la operación.
                using (SQLiteConnection connection = new SQLiteConnection(connectionString))
                {
                    connection.Open(); // Se abre la conexión con la base de datos.

                    // Se define una consulta SQL para actualizar el estado del recordatorio a "Destacado".
                    string updateQuery = "UPDATE Recordatorios SET Destacado = 1 WHERE ID_Recordatorios = @id";

                    // Se crea un nuevo comando SQL que ejecutará la actualización en la base de datos.
                    using (var command = new SQLiteCommand(updateQuery, connection))
                    {
                        // Se asigna el valor del ID del recordatorio al parámetro '@id' en la consulta SQL.
                        command.Parameters.AddWithValue("@id", item.ID_Recordatorios);

                        // Se ejecuta la consulta para actualizar el estado del recordatorio en la base de datos.
                        command.ExecuteNonQuery();
                    }
                }
            }
            catch (Exception ex)
            {
                // Si ocurre un error durante la actualización, se captura y se muestra un mensaje de error al usuario.
                MessageBox.Show($"Error al destacar el recordatorio: {ex.Message}");
                return; // Se detiene la ejecución si hay un problema.
            }

            // -------- NOTIFICAR QUE EL RECORDATORIO HA SIDO DESTACADO --------
            // Se dispara un evento para notificar que el estado de "Destacado" ha cambiado.
            // Este evento puede ser escuchado por otras partes del programa, como una vista de recordatorios destacados.
            RecordatorioEventAggregator.RaiseDestacadoToggled(item, true);

            // -------- MOSTRAR UNA CONFIRMACIÓN VISUAL --------
            // Se llama a un método que muestra un mensaje visual indicando que el recordatorio ha sido destacado.
            MostrarRecordatorioDestacado();
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'public', por lo que se puede acceder desde otra clase.
        // Método que muestra una notificación visual indicando que un recordatorio ha sido eliminado.
        public void MostrarRecordatorioEliminado()
        {
            // Se llama al método 'MostrarMensaje' para desplegar una confirmación en la interfaz.
            // El primer parámetro es el texto del mensaje que se mostrará al usuario, indicando la eliminación del recordatorio.
            // El segundo parámetro es el nombre de la imagen que se usa como ícono visual, en este caso, una imagen de eliminación.
            MostrarMensaje("Recordatorio eliminado", "eliminar.png");
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // Método que muestra una notificación visual indicando que un recordatorio ha sido marcado como destacado.
        private void MostrarRecordatorioDestacado()
        {
            // Se llama al método 'MostrarMensaje' para desplegar una confirmación en la interfaz.
            // El primer parámetro es el texto del mensaje que se mostrará al usuario, indicando que el recordatorio ha sido destacado.
            // El segundo parámetro es el nombre de la imagen utilizada como ícono visual, en este caso, una estrella rellena.
            MostrarMensaje("Recordatorio destacado", "EstrellaRellenada.png");

            // Se recargan los recordatorios desde la base de datos para reflejar el nuevo estado del recordatorio destacado.
            // Esto asegura que la lista en la interfaz se actualice y muestre los cambios realizados.
            CargarRecordatoriosDesdeBD();
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // La palabra clave 'async' permite usar 'await' dentro del método para hacer tareas asincrónicas sin bloquear la interfaz.
        /* Estos son los mensajes que te dicen cuando añadiste o eliminaste y destacaste un recordatorio */
        // Método asincrónico que muestra un mensaje visual en la interfaz con un ícono.
        // Se usa una animación para hacer que el mensaje aparezca y luego desaparezca automáticamente.
        private async void MostrarMensaje(string texto, string icono)
        {
            // -------- CREACIÓN DEL CONTENEDOR DEL MENSAJE --------
            // Se crea un borde (Border) que servirá como contenedor del mensaje.
            Border borde = new Border
            {
                Background = (Brush)new BrushConverter().ConvertFromString("#f4f4f4"), // Color de fondo del mensaje.
                CornerRadius = new CornerRadius(10), // Bordes redondeados para mejorar la apariencia.
                Margin = new Thickness(0, 15, 0, 0), // Espaciado para separar los mensajes entre sí.
                Padding = new Thickness(10), // Espaciado interno para una mejor legibilidad.
                Opacity = 0, // Se inicia con opacidad 0 para luego aplicar la animación de entrada.
                Child = new StackPanel // Se usa un StackPanel para organizar los elementos internos.
                {
                    Orientation = Orientation.Horizontal, // Se alinea la imagen y el texto en una fila.
                    Children =
            {
                // -------- IMAGEN DEL ÍCONO --------
                new Image
                {
                    Source = new BitmapImage(new Uri($"pack://application:,,,/Imagenes/{icono}", UriKind.Absolute)), // Se asigna la imagen usando la ruta del paquete de la aplicación.
                    Width = 24, // Tamaño de la imagen en píxeles.
                    Height = 24,
                    Margin = new Thickness(0, 0, 10, 0) // Espaciado a la derecha de la imagen para separar del texto.
                },
                // -------- TEXTO DEL MENSAJE --------
                new TextBlock
                {
                    Text = texto, // Se asigna el texto que mostrará el mensaje.
                    Foreground = Brushes.Black, // Color del texto.
                    VerticalAlignment = VerticalAlignment.Center, // Se alinea verticalmente con la imagen.
                    FontSize = 14, // Tamaño de la fuente.
                    TextWrapping = TextWrapping.Wrap // Se permite que el texto se ajuste en varias líneas si es necesario.
                }
            }
                }
            };

            // Se añade el mensaje al contenedor de mensajes de la interfaz.
            StackMensajes.Children.Add(borde);

            // -------- ANIMACIÓN DE ENTRADA (FADE-IN) --------
            // Se crea una animación para que el mensaje aparezca suavemente.
            DoubleAnimation fadeIn = new DoubleAnimation(0, 1, TimeSpan.FromMilliseconds(300)); // Cambia la opacidad de 0 a 1 en 300 ms.
            borde.BeginAnimation(Border.OpacityProperty, fadeIn); // Se aplica la animación al borde.

            // -------- ESPERA ANTES DE LA ANIMACIÓN DE SALIDA --------
            // Se espera 2.5 segundos antes de que el mensaje desaparezca, permitiendo que el usuario lo vea.
            await Task.Delay(2500);

            // -------- ANIMACIÓN DE SALIDA (FADE-OUT) --------
            // Se crea una animación para desvanecer el mensaje y eliminarlo de la interfaz.
            DoubleAnimation fadeOut = new DoubleAnimation(1, 0, TimeSpan.FromMilliseconds(300)); // Cambia la opacidad de 1 a 0 en 300 ms.

            // Se define un evento que se ejecutará cuando la animación termine.
            // Se eliminará el mensaje de la interfaz después de la animación.
            fadeOut.Completed += (s, e) => StackMensajes.Children.Remove(borde);

            // Se aplica la animación de salida al borde.
            borde.BeginAnimation(Border.OpacityProperty, fadeOut);
        }

        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // La palabra clave 'async' permite usar 'await' dentro del método para hacer tareas asincrónicas sin bloquear la interfaz.
        // Método asincrónico que oculta el contenedor de agregar recordatorio con una animación.
        // Se ejecuta cuando el usuario cierra el panel y permite que la animación se complete antes de ocultarlo completamente.
        private async Task OcultarContenedorAddRecordatorio()
        {
            // Se establece la variable 'animacionEnCurso' en 'true' para indicar que una animación está en ejecución.
            animacionEnCurso = true;

            // -------- OBTENER Y EJECUTAR LA ANIMACIÓN --------
            // Se obtiene la animación predefinida llamada "SlideOutToRightAnimation" desde los recursos de la interfaz.
            var slideOut = (Storyboard)FindResource("SlideOutToRightAnimation");

            // Se suscribe un evento que se ejecutará cuando la animación haya finalizado.
            slideOut.Completed += (s, ev) =>
            {
                // Cuando la animación termine, se oculta el contenedor de agregar recordatorio.
                ContenedorAddRecordatorio.Visibility = Visibility.Collapsed;
            };

            // Se inicia la animación en el elemento 'ContenedorAddRecordatorio'.
            slideOut.Begin(ContenedorAddRecordatorio);

            // -------- ESPERA DURANTE LA EJECUCIÓN DE LA ANIMACIÓN --------
            // Se espera 600 milisegundos (equivalente a la duración de la animación) antes de continuar con la ejecución.
            await Task.Delay(600);

            // -------- HABILITAR BOTÓN Y FINALIZAR ANIMACIÓN --------
            // Se habilita nuevamente el botón que permite abrir el contenedor de agregar recordatorio,
            // asegurándose de que la interfaz pueda recibir nuevas acciones del usuario.
            btnAbrirContenedor.IsEnabled = true;

            // Se marca que la animación ha finalizado para que otras acciones dependientes puedan ejecutarse sin restricciones.
            animacionEnCurso = false;
        }



        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // Método para actualizar los recordatorios cuando se regresa a InicioView
        // Método que actualiza la lista de recordatorios en la interfaz gráfica.
        // Se encarga de limpiar los recordatorios existentes y volver a cargarlos desde la base de datos.
        private void ActualizarRecordatorios()
        {
            // -------- LIMPIEZA DEL PANEL --------
            // Se eliminan todos los elementos actuales dentro del contenedor de recordatorios.
            // Esto evita que se acumulen duplicados cuando se recargan los datos.
            PanelRecordatorios.Children.Clear();

            // -------- RECARGA DE RECORDATORIOS --------
            // Se llama al método 'CargarRecordatoriosDesdeBD' para recuperar los recordatorios desde la base de datos.
            // Este método obtiene los recordatorios y los vuelve a añadir a la interfaz, asegurando que cualquier cambio se refleje correctamente.
            CargarRecordatoriosDesdeBD(); // Separa los recordatorios destacados y no destacados según el criterio definido.
        }

        // 'void' indica que el método no devuelve ningún valor.
        // Está marcado como 'private', por lo que solo puede ser accedido desde esta clase.
        // 'object sender' representa el objeto (el botón) que generó el evento.
        // 'RoutedEventArgs e' contiene información adicional sobre el evento de clic.
        // Método que maneja el evento de clic en un botón.
        // Este evento redirige la ejecución al método 'Button_Click', pasando los mismos parámetros.
        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            // Se llama al método 'Button_Click', reutilizando el evento sin modificarlo.
            // 'sender' es el objeto que activó el evento, y 'e' contiene los datos del evento.
            Button_Click(sender, e);
        }
    }
}